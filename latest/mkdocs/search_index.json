{
    "docs": [
        {
            "location": "/", 
            "text": "OpenDSSDirect\n\n\nOpenDSS\n is an open-source distribution system simulator. This Julia package implements a \"direct\" library interface to OpenDSS. See \nthis documentation\n for detailed information on the direct library interface to OpenDSS. The direct library interface can be faster than the more traditional COM interface.\n\n\nThis package is only available for Windows.\n OpenDSS is only available for Windows.\n\n\n\n\nInstallation\n\n\nFor now, this package is registered, so you can use the following to install:\n\n\nPkg\n.\nadd\n(\nOpenDSSDirect\n)\n\n\n\n\n\n\nTo install the latest development version, use the following from within Julia:\n\n\nPkg\n.\nclone\n(\nhttps://github.com/tshort/OpenDSSDirect.jl.git\n)\n\n\n\n\n\n\nThis package includes OpenDSS as a library. You do not have to install OpenDSS separately. In particular, it includes the OpenDSSDirect.DLL that implements the direct-access API.\n\n\n\n\nFeatures\n\n\nJulia\n is a fast, flexible numerical language with Matlab-like syntax. Like Python or Matlab, scripting OpenDSS can be used for  Monte-Carlo batch runs, parameter sweeps, post processing and plotting of  results, and more. \n\n\nJulia has several key features for advanced operations with OpenDSS:\n\n\n\n\n\n\nParallel operations\n \u2013 Julia supports several ways to process data in    parallel. This includes parallel operations on multiple CPU cores and    parallel operations on processes in a cluster. See    \nexamples/8760_pmap.jl\n    for an example of an annual simulation split among local CPU cores.\n\n\n\n\n\n\nOptimization\n \u2013 Julia has strong support for optimization.\n\n\n\n\n\n\nCustom solutions and custom models\n \u2013 Because Julia compiles to codes    that run as quickly as C programs, it is possible to implement custom   solutions, and these custom solutions can contain custom models implemented   in Julia. The basic idea is to run a custom solution as described in    \nOpenDSS Solution Interface.pdf\n.   Custom control or power control elements can be implemented between each   model iteration. See    \nexamples/low-level-solver.jl\n    for an example with a custom solver, including a case with an alternate sparse   matrix solver.\n\n\n\n\n\n\n\n\nContents\n\n\n\n\nMain API (module DSS)\n\n\nFlag objects\n\n\nDSS REPL Mode\n\n\nLow-level API (module DSSCore)\n\n\nDocumentation Index", 
            "title": "OpenDSSDirect"
        }, 
        {
            "location": "/#opendssdirect", 
            "text": "OpenDSS  is an open-source distribution system simulator. This Julia package implements a \"direct\" library interface to OpenDSS. See  this documentation  for detailed information on the direct library interface to OpenDSS. The direct library interface can be faster than the more traditional COM interface.  This package is only available for Windows.  OpenDSS is only available for Windows.", 
            "title": "OpenDSSDirect"
        }, 
        {
            "location": "/#installation", 
            "text": "For now, this package is registered, so you can use the following to install:  Pkg . add ( OpenDSSDirect )   To install the latest development version, use the following from within Julia:  Pkg . clone ( https://github.com/tshort/OpenDSSDirect.jl.git )   This package includes OpenDSS as a library. You do not have to install OpenDSS separately. In particular, it includes the OpenDSSDirect.DLL that implements the direct-access API.", 
            "title": "Installation"
        }, 
        {
            "location": "/#features", 
            "text": "Julia  is a fast, flexible numerical language with Matlab-like syntax. Like Python or Matlab, scripting OpenDSS can be used for  Monte-Carlo batch runs, parameter sweeps, post processing and plotting of  results, and more.   Julia has several key features for advanced operations with OpenDSS:    Parallel operations  \u2013 Julia supports several ways to process data in    parallel. This includes parallel operations on multiple CPU cores and    parallel operations on processes in a cluster. See     examples/8760_pmap.jl     for an example of an annual simulation split among local CPU cores.    Optimization  \u2013 Julia has strong support for optimization.    Custom solutions and custom models  \u2013 Because Julia compiles to codes    that run as quickly as C programs, it is possible to implement custom   solutions, and these custom solutions can contain custom models implemented   in Julia. The basic idea is to run a custom solution as described in     OpenDSS Solution Interface.pdf .   Custom control or power control elements can be implemented between each   model iteration. See     examples/low-level-solver.jl     for an example with a custom solver, including a case with an alternate sparse   matrix solver.", 
            "title": "Features"
        }, 
        {
            "location": "/#contents", 
            "text": "Main API (module DSS)  Flag objects  DSS REPL Mode  Low-level API (module DSSCore)  Documentation Index", 
            "title": "Contents"
        }, 
        {
            "location": "/api/", 
            "text": "Main API (module DSS)\n\n\nThe \ndss\n function is the main function for passing commands to OpenDSS. You can pass multi-line commands with \ndss\n. You can also splice in Julia values with string interpolation. Here is an  example of using \ndss\n:\n\n\nusing\n \nOpenDSSDirect\n\n\nfilename\n \n=\n \nC:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss\n\n\ndss\n(\n\n\n    clear\n\n\n    compile \n$filename\n\n\n)\n\n\n\n\n\n\nSeveral functions are available for setting OpenDSS variables, getting values, and initiating commands. Each of these is in one of several modules. Here is an  example to set the \nkW\n of the active load element:\n\n\nLoads\n.\nkW\n(\n50.\n)\n\n\n\n\n\n\nHere is an example setting some loads:\n\n\nusing\n \nOpenDSSDirect\n\n\nfilename\n \n=\n \nC:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss\n\n\ndss\n(\n\n\n    clear\n\n\n    compile \n$filename\n\n\n)\n\n\nloadnumber\n \n=\n \nDSS\n.\nLoads\n.\nFirst\n()\n\n\nwhile\n \nloadnumber\n \n \n0\n\n    \nDSS\n.\nLoads\n.\nkW\n(\n50.\n)\n\n    \nDSS\n.\nLoads\n.\nkvar\n(\n20.\n)\n\n    \nloadnumber\n \n=\n \nDSS\n.\nLoads\n.\nNext\n()\n\n\nend\n\n\nprintln\n(\nDSS\n.\nLoads\n.\nCount\n())\n \n\n\n\n\n\nTo use this API, you can either use \nimport OpenDSSDirect\n and prepend all of the functions with \nDSS.\n, or you can \nimport OpenDSSDirect.DSS\n and use the functions directly. The following two are equivalent:\n\n\nusing\n \nOpenDSSDirect\n\n\nDSS\n.\nCircuit\n.\nTotalPower\n()\n\n\n\n\n\n\nImporting the DSS module:\n\n\nusing\n \nOpenDSSDirect\n.\nDSS\n\n\nCircuit\n.\nTotalPower\n()\n\n\n\n\n\n\nMany of the functions that return arrays convert to complex numbers where appropriate. Here is an example session:\n\n\njulia\n \nusing\n \nOpenDSSDirect\n.\nDSS\n\n\n\njulia\n \nfilename\n \n=\n \njoinpath\n(\nPkg\n.\ndir\n(),\n \nOpenDSSDirect\n,\n \nexamples\n,\n \n8500-Node\n,\n \nMaster.dss\n);\n\n\n\njulia\n \ndss\n(\n\n\n           clear\n\n\n           compile \n$filename\n\n\n       \n)\n\n\n\njulia\n \nSolution\n.\nSolve\n();\n\n\n\njulia\n \nCircuit\n.\nLosses\n()\n\n\n1.218242333223247e6\n \n+\n \n2.798391857088721e6\nim\n\n\n\njulia\n \nCircuit\n.\nTotalPower\n()\n\n\n-\n12004.740450109337\n \n-\n \n1471.1749507157301\nim\n\n\n\njulia\n \nCircuit\n.\nSetActiveElement\n(\nCapacitor.CAPBank3\n)\n\n\n6075\n\n\n\njulia\n \nCktElement\n.\nVoltages\n()\n\n\n6\n-\nelement\n \nArray\n{\nComplex\n{\nFloat64\n},\n1\n}:\n\n  \n5390.82\n-\n4652.32\nim\n\n \n-\n6856.89\n-\n2274.93\nim\n\n  \n1284.62\n+\n7285.18\nim\n\n      \n0.0\n+\n0.0\nim\n\n      \n0.0\n+\n0.0\nim\n\n      \n0.0\n+\n0.0\nim\n\n\n\n\n\n\nTo find the functions available in each module, use Julia's help for each module (initiated by hitting \n?\n). See below for an example. \n\n\njulia\n \nusing\n \nOpenDSSDirect\n.\nDSS\n\n\n\nhelp\n?\n \nCircuit\n\n\nsearch\n:\n \nCircuit\n\n\n  \nmodule\n \nCircuit\n \n\u2013\n \nFunctions\n \nfor\n \ninterfacing\n \nwith\n \nthe\n \nactive\n \nOpenDSS\n \ncircuit\n.\n\n\n  \nCircuit\n.\nNumCktElements\n()\n \n\u2013\n \nNumber\n \nof\n \nCktElements\n \nin\n \nthe\n \ncircuit\n\n\n  \nCircuit\n.\nNumBuses\n()\n \n\u2013\n \nTotal\n \nnumber\n \nof\n \nBuses\n \nin\n \nthe\n \ncircuit\n\n\n  \nCircuit\n.\nNumNodes\n()\n \n\u2013\n \nTotal\n \nnumber\n \nof\n \nNodes\n \nin\n \nthe\n \ncircuit\n\n\n  \nCircuit\n.\nFirstPCElement\n()\n \n\u2013\n \nSets\n \nthe\n \nfirst\n \nenabled\n \nPower\n \nConversion\n \n(\nPC\n)\n \nelement\n \nin\n \nthe\n \ncircuit\n \nto\n \nbe\n \nactive\n;\n \nif\n \nnot\n \nsuccessful\n \nreturns\n \na\n \n0\n\n\n  \nCircuit\n.\nNextPCElement\n()\n \n\u2013\n \nSets\n \nthe\n \nnext\n \nenabled\n \nPower\n \nConversion\n \n(\nPC\n)\n \nelement\n \nin\n \nthe\n \ncircuit\n \nto\n \nbe\n \nactive\n;\n \nif\n \nnot\n \nsuccessful\n \nreturns\n \na\n \n0\n\n\n  \nCircuit\n.\nFirstPDElement\n()\n \n\u2013\n \nSets\n \nthe\n \nfirst\n \nenabled\n \nPower\n \nDelivery\n \n(\nPD\n)\n \nelement\n \nin\n \nthe\n \ncircuit\n \nto\n \nbe\n \nactive\n;\n \nif\n \nnot\n \nsuccessful\n \nreturns\n \na\n \n0\n\n\n  \nCircuit\n.\nNextPDElement\n()\n \n\u2013\n \nSets\n \nthe\n \nnext\n \nenabled\n \nPower\n \nDelivery\n \n(\nPD\n)\n \nelement\n \nin\n \nthe\n \ncircuit\n \nto\n \nbe\n \nactive\n;\n \nif\n \nnot\n \nsuccessful\n \nreturns\n \na\n \n0\n\n\n  \n{\ntruncated\n...\n}\n\n\n\n\n\n\nHere is a list of modules supported by this API. Each module has several functions.\n\n\n\n\nActiveClass\n\n\nBasic\n\n\nBus\n\n\nCapControls\n\n\nCapacitors\n\n\nCircuit\n\n\nCktElement\n\n\nCtrlQueue\n\n\nElement\n\n\nExecutive\n\n\nFuses\n\n\nGenerators\n\n\nIsource\n\n\nLines\n\n\nLoadShape\n\n\nLoads\n\n\nMeters\n\n\nMonitors\n\n\nPDElements\n\n\nPVsystems\n\n\nParser\n\n\nProgress\n\n\nProperties\n\n\nReclosers\n\n\nRegControls\n\n\nRelays\n\n\nSensors\n\n\nSettings\n\n\nSolution\n\n\nSwtControls\n\n\nTopology\n\n\nTransformers\n\n\nVsources\n\n\nXYCurves\n\n\ndss\n\n\n\n\n\n\ndss\n\n\n#\nOpenDSSDirect.DSS.dss\n \n \nFunction\n.\n\n\n\n\ndss(arg::AbstractString)\n\n\nExecute the OpenDSS text command \narg\n.\n\n\n\n\nActiveClass\n\n\n#\nOpenDSSDirect.DSS.ActiveClass\n \n \nModule\n.\n\n\n\n\nmodule ActiveClass\n \u2013 Functions for interfacing with the active OpenDSS class.\n\n\nActiveClass.First()\n \u2013 Sets the first element in the active class to be the active object; if object is a CktElement, ActiveCktElement also points to this element; returns 0 if none\n\n\nActiveClass.Next()\n \u2013 Sets the next element in the active class to be the active object; if object is a CktElement, ActiveCktElement also points to this element; returns 0 if no more\n\n\nActiveClass.NumElements()\n \u2013 Number of elements in the active class\n\n\nActiveClass.Count()\n \u2013 Number of elements in the active class; same as NumElements\n\n\nActiveClass.Name()\n \u2013 Name of the active element of the active class\n\n\nActiveClass.Name(arg)\n \u2013 Set the name of the active element of the active class\n\n\nActiveClass.ActiveClassName()\n \u2013 Name of the active class\n\n\nActiveClass.AllNames()\n \u2013 All element names in the active class\n\n\n\n\nBasic\n\n\n#\nOpenDSSDirect.DSS.Basic\n \n \nModule\n.\n\n\n\n\nmodule Basic\n \u2013 Includes methods for basic OpenDSS information.\n\n\nBasic.NumCircuits()\n \u2013 Number\u00a0of\u00a0Circuits\u00a0currently\u00a0defined\n\n\nBasic.ClearAll()\n \u2013 Clears\u00a0all\u00a0circuit\u00a0definitions\n\n\nBasic.ShowPanel()\n \u2013 Shows\u00a0non\u2010MDI\u00a0child\u00a0form\u00a0of\u00a0the\u00a0Main\u00a0DSS\u00a0Edit\u00a0Form\n\n\nBasic.Start()\n \u2013 Validate\u00a0the\u00a0user\u00a0and\u00a0start\u00a0OpenDSS; returns\u00a0true\u00a0if\u00a0successful\n\n\nBasic.NumClasses()\n \u2013 Number\u00a0of\u00a0DSS\u00a0intrinsic\u00a0classes\n\n\nBasic.NumUserClasses()\n \u2013 Number\u00a0of\u00a0user\u2010defined\u00a0classes\n\n\nBasic.Reset()\n \u2013 Resets\u00a0DSS\u00a0Initialization\u00a0for\u00a0restarts\n\n\nBasic.AllowForms()\n \u2013 Bool flag on the status of allowing forms\n\n\nBasic.AllowForms(arg)\n \u2013 Bool flag to disable forms (once disabled, can\u2019t be enabled again)\n\n\nBasic.NewCircuit()\n \u2013 Make\u00a0a\u00a0new\u00a0circuit\n\n\nBasic.Version()\n \u2013 Get\u00a0version\u00a0string\u00a0for\u00a0OpenDSS\n\n\nBasic.DataPath()\n \u2013 Default\u00a0file path\u00a0for\u00a0reports,\u00a0etc.\n\n\nBasic.DataPath(arg)\n \u2013 Set the default file path\u00a0for\u00a0reports,\u00a0etc.\n\n\nBasic.DefaultEditor()\n \u2013 The\u00a0path\u00a0name\u00a0for\u00a0the\u00a0default\u00a0text\u00a0editor\n\n\nBasic.Classes()\n \u2013 List of the names of intrinsic classes\n\n\nBasic.UserClasses()\n \u2013 List of the names of user-defined classes\n\n\n\n\nBus\n\n\n#\nOpenDSSDirect.DSS.Bus\n \n \nModule\n.\n\n\n\n\nmodule Bus\n \u2013 Functions for interfacing with the active OpenDSS bus.\n\n\nBus.NumNodes()\n \u2013 Number of nodes\n\n\nBus.ZscRefresh()\n \u2013 Refresh Zsc and Ysc values; execute after a major change in the circuit\n\n\nBus.Coorddefined()\n \u2013 Returns true if the X-Y coordinates are defined for the active bus\n\n\nBus.GetUniqueNodeNumber()\n \u2013 Returns\u00a0a\u00a0unique\u00a0node\u00a0number\u00a0at\u00a0the\u00a0active\u00a0bus\u00a0to\u00a0avoid node\u00a0collisions\u00a0and\u00a0adds\u00a0it\u00a0to\u00a0the\u00a0node\u00a0list\u00a0for\u00a0the\u00a0bus\n\n\nBus.N_Customers()\n \u2013 Returns the total number of customers downline from the active bus after reliability calcs\n\n\nBus.SectionID()\n \u2013 Integer ID of the feeder section in which this bus is located\n\n\nBus.kVBase()\n \u2013 Base voltage\n\n\nBus.X()\n \u2013 X coordinate of the bus\n\n\nBus.X(arg)\n \u2013 Set the X coordinate of the bus\n\n\nBus.Y()\n \u2013 Y coordinate of the bus\n\n\nBus.Y(arg)\n \u2013 Set the Y coordinate of the bus\n\n\nBus.Distance()\n \u2013 Distance in km that this bus isfrom the parent EnergyMeter\n\n\nBus.Lambda()\n \u2013 Total annual failure rate for active bus after reliability calcs\n\n\nBus.N_interrupts()\n \u2013 Number\u00a0of\u00a0interruptions\u00a0this\u00a0bus\u00a0per\u00a0year\n\n\nBus.Int_Duration()\n \u2013 Average interruption duration, hours\n\n\nBus.Cust_Interrupts()\n \u2013 Annual number of customer-interruptions from this bus\n\n\nBus.Cust_Duration()\n \u2013 Accumulated customer outage durations, hours\n\n\nBus.TotalMiles()\n \u2013 Total length of line downline from this bus, miles\n\n\nBus.Name()\n \u2013 Active bus name; set the active bus by name with \ncircuit.SetActiveBus(name)\n\n\nBus.Voltages()\n \u2013 Bus voltages, complex\n\n\nBus.SeqVoltages()\n \u2013 Sequence voltages in order of 0, 1, then 2\n\n\nBus.Nodes()\n \u2013 Vector of node numbers defined at the bus in the same order as the voltages\n\n\nBus.Voc()\n \u2013 Open-circuit voltage vector, complex\n\n\nBus.Isc()\n \u2013 Short-circuit current vector, complex\n\n\nBus.PuVoltage()\n \u2013 Per-unit voltages at the bus, complex\n\n\nBus.ZscMatrix()\n \u2013 Short-circuit impedance matrix, complex\n\n\nBus.Zsc1()\n \u2013 Positive-sequence short-circuit impedance looking into the bus, complex\n\n\nBus.Zsc0()\n \u2013 Zero-sequence short-circuit impedance looking into the bus, complex\n\n\nBus.YscMatrix()\n \u2013 Short-circuit admittance matrix, complex\n\n\nBus.CplxSeqVoltages()\n \u2013 All complex sequence voltages\n\n\nBus.VLL()\n \u2013 Complex vector of line-to-line voltages for 2- and 3-phase buses; returns -1. for a 1-phase bus; for more than 3 phases, only returns 3 phases\n\n\nBus.puVLL()\n \u2013 Complex vector of per-unit line-to-line voltages for 2- and 3-phase buses; returns -1. for a 1-phase bus; for more than 3 phases, only returns 3 phases\n\n\nBus.VMagAngle()\n \u2013 Bus voltage magnitudes with angles\n\n\nBus.puVmagAngle()\n \u2013 Bus voltage magnitudes (per unit) with angles\n\n\n\n\nCapacitors\n\n\n#\nOpenDSSDirect.DSS.Capacitors\n \n \nModule\n.\n\n\n\n\nmodule Capacitors\n \u2013 Functions for interfacing with the active OpenDSS capacitor.\n\n\nCapacitors.NumSteps()\n \u2013 Number\u00a0of\u00a0steps\n\n\nCapacitors.NumSteps(arg)\n \u2013 Set the number\u00a0of\u00a0steps\n\n\nCapacitors.IsDelta()\n \u2013 Is the connection a delta\n\n\nCapacitors.IsDelta(arg)\n \u2013 Set connection type; use \narg==true\n for delta and \narg==false\n for wye\n\n\nCapacitors.First()\n \u2013 Sets the first Capacitor active; returns 0 if none\n\n\nCapacitors.Next()\n \u2013 Sets the next Capacitor active; returns 0 if no more\n\n\nCapacitors.Count()\n \u2013 Number of capacitor objects in the active circuit\n\n\nCapacitors.AddStep()\n \u2013 Adds one step of the capacitor if available; if successful, returns 1\n\n\nCapacitors.SubtractStep()\n \u2013 Subtracts one step of the capacitor; if no more steps, returns 0\n\n\nCapacitors.AvailableSteps()\n \u2013 Number of steps available in the cap bank to be switched ON\n\n\nCapacitors.Open()\n \u2013 Open all steps, all phases of the capacitor\n\n\nCapacitors.Close()\n \u2013 Close all steps of all phases of the capacitor\n\n\nCapacitors.kV()\n \u2013 Bank\u00a0kV\u00a0rating; use\u00a0LL\u00a0for\u00a02\u00a0or\u00a03\u00a0phases,\u00a0or\u00a0actual\u00a0can\u00a0rating\u00a0for\u00a01\u00a0phase\n\n\nCapacitors.kV(arg)\n \u2013 Set the bank\u00a0kV\u00a0rating; use\u00a0LL\u00a0for\u00a02\u00a0or\u00a03\u00a0phases,\u00a0or\u00a0actual\u00a0can\u00a0rating\u00a0for\u00a01\u00a0phase\n\n\nCapacitors.kvar()\n \u2013 Total\u00a0bank\u00a0kvar,\u00a0distributed\u00a0equally\u00a0among\u00a0phases\u00a0and\u00a0steps\n\n\nCapacitors.kvar(arg)\n \u2013 Set the total\u00a0bank\u00a0kvar,\u00a0distributed\u00a0equally\u00a0among\u00a0phases\u00a0and\u00a0steps\n\n\nCapacitors.Name()\n \u2013 The name of the active capacitor\n\n\nCapacitors.Name(arg)\n \u2013 Sets the active capacitor by name\n\n\nCapacitors.AllNames()\n \u2013 All capacitor names in the circuit\n\n\nCapacitors.States()\n \u2013 A vector of \u00a0integers\u00a0[0..numsteps\u20101]\u00a0indicating\u00a0state\u00a0of\u00a0each\u00a0step; if value\u00a0is\u00a0\u20101\u00a0an\u00a0error\u00a0has\u00a0occurred.\n\n\n\n\nCapControls\n\n\n#\nOpenDSSDirect.DSS.CapControls\n \n \nModule\n.\n\n\n\n\nmodule CapControls\n \u2013 Functions for interfacing with the active OpenDSS CapControl.\n\n\nCapControls.First()\n \u2013 Sets the first CapControl active; returns 0 if none\n\n\nCapControls.Next()\n \u2013 Sets the next CapControl active; returns 0 if no more\n\n\nCapControls.Mode()\n \u2013 Type of automatic controller; for meaning, see CapControlModes\n\n\nCapControls.Mode(arg)\n \u2013 Set the type of automatic controller; for choices, see CapControlModes\n\n\nCapControls.MonitoredTerm()\n \u2013 Terminal\u00a0number\u00a0on\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to\n\n\nCapControls.MonitoredTerm(arg)\n \u2013 Set the terminal\u00a0number\u00a0on\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to\n\n\nCapControls.UseVoltOverride()\n \u2013 Bool flag that enables\u00a0Vmin\u00a0and\u00a0Vmax\u00a0to\u00a0override\u00a0the\u00a0control\u00a0mode\n\n\nCapControls.UseVoltOverride(arg)\n \u2013 Set the Bool flag that enables\u00a0Vmin\u00a0and\u00a0Vmax\u00a0to\u00a0override\u00a0the\u00a0control\u00a0mode\n\n\nCapControls.Count()\n \u2013 Number of CapControls in the active circuit\n\n\nCapControls.CTRatio()\n \u2013 Transducer\u00a0ratio\u00a0from\u00a0primary\u00a0current\u00a0to\u00a0control\u00a0current\n\n\nCapControls.CTRatio(arg)\n \u2013 Set the transducer\u00a0ratio\u00a0from\u00a0primary\u00a0current\u00a0to\u00a0control\u00a0current\n\n\nCapControls.PTRatio()\n \u2013 Transducer\u00a0ratio\u00a0from\u00a0primary\u00a0voltage\u00a0to\u00a0control\u00a0voltage\n\n\nCapControls.PTRatio(arg)\n \u2013 Set the transducer\u00a0ratio\u00a0from\u00a0primary\u00a0voltage\u00a0to\u00a0control\u00a0voltage\n\n\nCapControls.ONSetting()\n \u2013 Threshold\u00a0to\u00a0arm\u00a0or\u00a0switch\u00a0on\u00a0a\u00a0step; see\u00a0Mode\u00a0for\u00a0units\n\n\nCapControls.ONSetting(arg)\n \u2013 Set the threshold\u00a0to\u00a0arm\u00a0or\u00a0switch\u00a0on\u00a0a\u00a0step; see\u00a0Mode\u00a0for\u00a0units\n\n\nCapControls.OFFSetting()\n \u2013 Threshold\u00a0to\u00a0switch\u00a0off\u00a0a\u00a0step; see\u00a0the particular CapControlModes option\u00a0for\u00a0units\n\n\nCapControls.OFFSetting(arg)\n \u2013 Set the threshold\u00a0to\u00a0switch\u00a0off\u00a0a\u00a0step; see\u00a0the particular CapControlModes option\u00a0for\u00a0units\n\n\nCapControls.Vmax()\n \u2013 With\u00a0VoltOverride,\u00a0switch\u00a0off\u00a0whenever\u00a0PT\u00a0voltage\u00a0exceeds\u00a0this\u00a0level\n\n\nCapControls.Vmax(arg)\n \u2013 Set Vmax; with\u00a0VoltOverride,\u00a0switch\u00a0off\u00a0whenever\u00a0PT\u00a0voltage\u00a0exceeds\u00a0this\u00a0level\n\n\nCapControls.Vmin()\n \u2013 With\u00a0VoltOverride,\u00a0switch\u00a0on\u00a0whenever\u00a0PT\u00a0voltage\u00a0drops below\u00a0this\u00a0level\n\n\nCapControls.Vmin(arg)\n \u2013 Set Vmin; with\u00a0VoltOverride,\u00a0switch\u00a0on\u00a0whenever\u00a0PT\u00a0voltage\u00a0drops below\u00a0this\u00a0level\n\n\nCapControls.Delay()\n \u2013 Time\u00a0delay\u00a0[s]\u00a0to\u00a0switch\u00a0on\u00a0after\u00a0arming; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching\n\n\nCapControls.Delay(arg)\n \u2013 Set the time\u00a0delay\u00a0[s]\u00a0to\u00a0switch\u00a0on\u00a0after\u00a0arming; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching\n\n\nCapControls.DelayOff()\n \u2013 Time\u00a0delay\u00a0[s]\u00a0before\u00a0switching\u00a0off\u00a0a\u00a0step; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching\n\n\nCapControls.DelayOff(arg)\n \u2013 Set the time\u00a0delay\u00a0[s]\u00a0before\u00a0switching\u00a0off\u00a0a\u00a0step; control\u00a0may\u00a0reset\u00a0before\u00a0actually switching\n\n\nCapControls.Name()\n \u2013 The name of the active CapControl\n\n\nCapControls.Name(arg)\n \u2013 Set the active CapControl by name\n\n\nCapControls.Capacitor()\n \u2013 Name of the Capacitor that is controlled\n\n\nCapControls.Capacitor(arg)\n \u2013 Set the Capacitor (by name) that is controlled\n\n\nCapControls.MonitoredObj()\n \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to\n\n\nCapControls.MonitoredObj(arg)\n \u2013 Set the\u00a0element\u00a0(by full name) that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to\n\n\nCapControls.AllNames()\n \u2013 Names of all CapControls in the circuit\n\n\n\n\nCircuit\n\n\n#\nOpenDSSDirect.DSS.Circuit\n \n \nModule\n.\n\n\n\n\nmodule Circuit\n \u2013 Functions for interfacing with the active OpenDSS circuit.\n\n\nCircuit.NumCktElements()\n \u2013 Number of CktElements in the circuit\n\n\nCircuit.NumBuses()\n \u2013 Total number of Buses in the circuit\n\n\nCircuit.NumNodes()\n \u2013 Total number of Nodes in the circuit\n\n\nCircuit.FirstPCElement()\n \u2013 Sets the first enabled Power Conversion (PC) element in the circuit to be active; if not successful returns a 0\n\n\nCircuit.NextPCElement()\n \u2013 Sets the next enabled Power Conversion (PC) element in the circuit to be active; if not successful returns a 0\n\n\nCircuit.FirstPDElement()\n \u2013 Sets the first enabled Power Delivery (PD) element in the circuit to be active; if not successful returns a 0\n\n\nCircuit.NextPDElement()\n \u2013 Sets the next enabled Power Delivery (PD) element in the circuit to be active; if not successful returns a 0\n\n\nCircuit.Sample()\n \u2013 Force\u00a0all\u00a0Meters\u00a0and\u00a0Monitors\u00a0to\u00a0take\u00a0a\u00a0sample\n\n\nCircuit.SaveSample()\n \u2013 Force\u00a0all\u00a0Meters\u00a0and\u00a0Monitors\u00a0to\u00a0save\u00a0their\u00a0current\u00a0buffers\n\n\nCircuit.SetActiveBusi(arg)\n \u2013 Sets the active bus by integer index. The index is 0 based. That is, the first bus has an index of 0. Returns -1 if an error occurs.\n\n\nCircuit.FirstElement()\n \u2013 Sets\u00a0First\u00a0element\u00a0of\u00a0active\u00a0class\u00a0to\u00a0be\u00a0the\u00a0Active\u00a0element\u00a0in\u00a0the\u00a0active circuit.\u00a0Returns\u00a00\u00a0if\u00a0none.\n\n\nCircuit.NextElement()\n \u2013 Sets\u00a0the\u00a0next\u00a0element\u00a0of\u00a0the\u00a0active\u00a0class\u00a0to\u00a0be\u00a0the\u00a0active\u00a0element\u00a0in\u00a0the active\u00a0circuit.\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more\u00a0elements.\n\n\nCircuit.UpdateStorage()\n \u2013 Forces\u00a0update\u00a0to\u00a0all\u00a0storage\u00a0classes.\u00a0Typically\u00a0done\u00a0after\u00a0a\u00a0solution. Done\u00a0automatically\u00a0in\u00a0intrinsic\u00a0solution\u00a0modes.\n\n\nCircuit.ParentPDElement()\n \u2013 Sets\u00a0Parent\u00a0PD\u00a0element,\u00a0if\u00a0any,\u00a0to\u00a0be\u00a0the\u00a0active\u00a0circuit\u00a0element\u00a0and returns\u00a0index\n0;\u00a0Returns\u00a00\u00a0if\u00a0it\u00a0fails\u00a0or\u00a0not\u00a0applicable.\n\n\nCircuit.EndOfTimeStepUpdate()\n \u2013 Calls\u00a0EndOfTimeStepCleanup\u00a0in\u00a0SolutionAlgs\n\n\nCircuit.Capacity(arg1, arg2)\n \u2013 Executes the DSS capacity function. Start is the per unit load multiplier for the current year at which to start the search. Increment is the per unit value by which the load increments for each step of the analysis. The program sets the load at the Start value the PRESENT YEAR (including growth) and increments the load until something in thecircuit reports an overload or undervoltage violation. The function returns the total load at which the violation occurs or the peak load for the present year if no violations.\n\n\nCircuit.Name()\n \u2013 Name of the active circuit\n\n\nCircuit.Disable(arg)\n \u2013 Disable a circuit element by name (full name).\n\n\nCircuit.Enable(arg)\n \u2013 Enable a circuit element by name (full name).\n\n\nCircuit.SetActiveElement(arg)\n \u2013 Activate an element of the active circuit by name. Returns a string with the index of the active element.\n\n\nCircuit.SetActiveBus(arg)\n \u2013 Sets the active bus by name. Returns a 0 based index of the bus to use for future direct indexing of bus values returned in arrays. Returns -1 if an error occurs.\n\n\nCircuit.SetActiveClass(arg)\n \u2013 Sets\u00a0the\u00a0active\u00a0class\u00a0by\u00a0name.\u00a0\u00a0Use\u00a0FirstElement,\u00a0NextElement\u00a0to iterate\u00a0through\u00a0the\u00a0class.\u00a0Returns\u00a0\u20101\u00a0if\u00a0fails.\n\n\nCircuit.Losses()\n \u2013 Watt and var losses in the entire circuit, complex\n\n\nCircuit.LineLosses()\n \u2013 Watt and var losses in all the Line elements in the circuit, complex\n\n\nCircuit.SubstationLosses()\n \u2013 Watt and var losses in all the Transformer elements in the circuit that are designated as substations\n\n\nCircuit.TotalPower()\n \u2013 Returns the total power in kW and kvar supplied to the circuit by all Vsource and Isource objects. Does not include Generator objects. Complex.\n\n\nCircuit.AllBusVolts()\n \u2013 Returns the voltage (complex) for every node in the circuit as a complex vector. The order of the array is the same as AllNodeNames property. The array is constructed bus-by-bus and then by node at each bus. Thus, all nodes from each bus are grouped together.\n\n\nCircuit.AllBusVMag()\n \u2013 Similar to AllBusVolts except magnitude only (in actual volts). Returns the voltage (magnitude) for every node in the circuit as a complex vector.\n\n\nCircuit.AllElementNames()\n \u2013 The names of all elements\n\n\nCircuit.AllBusNames()\n \u2013 The names of all buses in the system. See \n:AllNodeNames\n.\n\n\nCircuit.AllElementLosses()\n \u2013 Returns the watt and var losses in each element of the system as a complex vector. Order is the same as AllElementNames.\n\n\nCircuit.AllBusMagPu()\n \u2013 Similar to AllBusVmag except that the magnitudes are reported in per unit for all buses with kVBase defined.\n\n\nCircuit.AllNodeNames()\n \u2013 Returns the names of all nodes (busname.nodenumber) in the same order as AllBusVolts, AllBusVmag, and AllBusVMagPu\n\n\nCircuit.SystemY()\n \u2013 Return the System Y matrix as a complex (dense) matrix\n\n\nCircuit.AllBusDistances()\n \u2013 Returns all distances from a bus to its parent EnergyMeter element, which is generally in the substation, as a variant array of doubles. Order corresponds to that of all bus properties.\n\n\nCircuit.AllNodeDistances()\n \u2013 Returns the distance from all nodes to the parent energy meter that match the designated phase number. Returns a vector of doubles. Matches the order of AllNodeNamesByPhase, AllNodeVmagByPhase, AllNodeVmagPUByPhase.\n\n\nCircuit.YNodeVArray()\n \u2013 Complex\u00a0array\u00a0of\u00a0actual\u00a0node\u00a0voltages\u00a0in\u00a0same\u00a0order\u00a0as\u00a0SystemY matrix.\n\n\nCircuit.YNodeOrder()\n \u2013 The\u00a0names\u00a0of\u00a0the\u00a0nodes\u00a0in\u00a0the\u00a0same order\u00a0as\u00a0the\u00a0Y\u00a0matrix\n\n\nCircuit.YCurrents()\n \u2013 Vector\u00a0of\u00a0doubles\u00a0containing\u00a0complex\u00a0injection\u00a0currents\u00a0for\u00a0the present\u00a0solution.\n\n\n\n\nCktElement\n\n\n#\nOpenDSSDirect.DSS.CktElement\n \n \nModule\n.\n\n\n\n\nmodule CktElement\n \u2013 Functions for interfacing with the active OpenDSS CktElement.\n\n\nCktElement.NumTerminals()\n \u2013 Number\u00a0of\u00a0Terminals\u00a0on this\u00a0Circuit\u00a0Element\n\n\nCktElement.NumConductors()\n \u2013 Number\u00a0of\u00a0Conductors\u00a0per\u00a0Terminal\n\n\nCktElement.NumPhases()\n \u2013 Number of phases\n\n\nCktElement.Open()\n \u2013 Open\u00a0the\u00a0specified\u00a0terminal\u00a0and\u00a0phase,\u00a0if\u00a0non\u2010zero.\u00a0\u00a0Else\u00a0all\u00a0conductors\u00a0at terminal.\n\n\nCktElement.Close()\n \u2013 Close\u00a0the\u00a0specified\u00a0terminal\u00a0and\u00a0phase,\u00a0if\u00a0non\u2010zero.\u00a0\u00a0Else\u00a0all\u00a0conductors\u00a0at terminal.\n\n\nCktElement.IsOpen()\n \u2013 Bool\u00a0indicating\u00a0if\u00a0the\u00a0specified\u00a0terminal\u00a0and,\u00a0optionally,\u00a0phase\u00a0is\u00a0open.\n\n\nCktElement.NumProperties()\n \u2013 Number\u00a0of\u00a0Properties\u00a0this\u00a0Circuit\u00a0Element.\n\n\nCktElement.HasSwitchControl()\n \u2013 Bool indicating whether this\u00a0element\u00a0has\u00a0a\u00a0SwtControl\u00a0attached.\n\n\nCktElement.HasVoltControl()\n \u2013 This\u00a0element\u00a0has\u00a0a\u00a0CapControl\u00a0or\u00a0RegControl\u00a0attached.\n\n\nCktElement.NumControls()\n \u2013 Number\u00a0of\u00a0controls\u00a0connected\u00a0to\u00a0this\u00a0device.\u00a0Use\u00a0to\u00a0determine\u00a0valid range\u00a0for\u00a0index\u00a0into\u00a0Controller\u00a0array.\n\n\nCktElement.OCPDevIndex()\n \u2013 Index\u00a0into\u00a0Controller\u00a0list\u00a0of\u00a0OCP\u00a0Device\u00a0controlling\u00a0this\u00a0CktElement\n\n\nCktElement.OCPDevType()\n \u2013 0=None;\u00a01=Fuse;\u00a02=Recloser;\u00a03=Relay;\u00a0\u00a0Type\u00a0of\u00a0OCP\u00a0controller\u00a0device\n\n\nCktElement.Enabled()\n \u2013 Element is enabled\n\n\nCktElement.Enabled(arg)\n \u2013 Enable the active circuit element\n\n\nCktElement.NormalAmps()\n \u2013 Normal\u00a0ampere\u00a0rating\u00a0for\u00a0PD\u00a0Elements\n\n\nCktElement.NormalAmps(arg)\n \u2013 Set the normal\u00a0ampere\u00a0rating\u00a0for\u00a0PD\u00a0Elements\n\n\nCktElement.EmergAmps()\n \u2013 Emergency\u00a0Ampere\u00a0Rating\u00a0for\u00a0PD\u00a0elements\n\n\nCktElement.EmergAmps(arg)\n \u2013 Set the emergency\u00a0Ampere\u00a0Rating\u00a0for\u00a0PD\u00a0elements\n\n\nCktElement.Variablei()\n \u2013 For\u00a0PCElement,\u00a0get\u00a0the\u00a0value\u00a0of\u00a0a\u00a0variable\u00a0by\u00a0integer\u00a0index.\n\n\nCktElement.Name()\n \u2013 Full\u00a0Name\u00a0of\u00a0Active\u00a0Circuit\u00a0Element\n\n\nCktElement.DisplayName()\n \u2013 Display\u00a0name\u00a0of\u00a0the\u00a0object\u00a0(not\u00a0necessarily\u00a0unique)\n\n\nCktElement.DisplayName(arg)\n \u2013 Set the display\u00a0name\u00a0of\u00a0the\u00a0object\u00a0(not\u00a0necessarily\u00a0unique)\n\n\nCktElement.GUID()\n \u2013 Globally\u00a0unique\u00a0identifier\u00a0for\u00a0this\u00a0object\n\n\nCktElement.EnergyMeter()\n \u2013 Name\u00a0of\u00a0the\u00a0Energy\u00a0Meter\u00a0this\u00a0element\u00a0is\u00a0assigned\u00a0to\n\n\nCktElement.Controller()\n \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0i\u2010th\u00a0controller\u00a0attached\u00a0to\u00a0this\u00a0element.\u00a0Ex:\u00a0str\u00a0=\u00a0Controller\n\n\nCktElement.BusNames()\n \u2013 Get\u00a0\u00a0Bus\u00a0definitions\u00a0to\u00a0which\u00a0each\u00a0terminal\u00a0is connected.\u00a00\u2010based\u00a0array.\n\n\nCktElement.Voltages()\n \u2013 Complex\u00a0array\u00a0of\u00a0voltages\u00a0at\u00a0terminals\n\n\nCktElement.Currents()\n \u2013 Complex\u00a0array\u00a0of\u00a0currents\u00a0into\u00a0each\u00a0conductor\u00a0of\u00a0each\u00a0terminal\n\n\nCktElement.Powers()\n \u2013 Complex\u00a0array\u00a0of\u00a0powers\u00a0into\u00a0each\u00a0conductor\u00a0of\u00a0each\u00a0terminal\n\n\nCktElement.Losses()\n \u2013 Total\u00a0losses\u00a0in\u00a0the\u00a0element:\u00a0two\u2010element\u00a0complex\u00a0array\n\n\nCktElement.PhaseLosses()\n \u2013 Complex\u00a0array\u00a0of\u00a0losses\u00a0by\u00a0phase\n\n\nCktElement.SeqVoltages()\n \u2013 Double\u00a0array\u00a0of\u00a0symmetrical\u00a0component\u00a0voltages\u00a0at\u00a0each\u00a03\u2010phase terminal\n\n\nCktElement.SeqCurrents()\n \u2013 Double\u00a0array\u00a0of\u00a0symmetrical\u00a0component\u00a0currents\u00a0into\u00a0each\u00a03\u2010phase terminal\n\n\nCktElement.SeqPowers()\n \u2013 Double\u00a0array\u00a0of\u00a0sequence\u00a0powers\u00a0into\u00a0each\u00a03\u2010phase\u00a0teminal\n\n\nCktElement.AllPropertyNames()\n \u2013 All\u00a0property\u00a0names\u00a0of\u00a0the\u00a0active\u00a0device.\n\n\nCktElement.Residuals()\n \u2013 Residual\u00a0currents\u00a0for\u00a0each\u00a0terminal:\u00a0(mag,\u00a0angle)\n\n\nCktElement.YPrim()\n \u2013 YPrim\u00a0matrix,\u00a0column\u00a0order,\u00a0complex\u00a0numbers\n\n\nCktElement.CplxSeqVoltages()\n \u2013 Complex\u00a0double\u00a0array\u00a0of\u00a0Sequence\u00a0Voltage\u00a0for\u00a0all\u00a0terminals\u00a0of\u00a0active circuit\u00a0element.\n\n\nCktElement.CplxSeqCurrents()\n \u2013 Complex\u00a0double\u00a0array\u00a0of\u00a0Sequence\u00a0Currents\u00a0for\u00a0all\u00a0conductors\u00a0of\u00a0all terminals\u00a0of\u00a0active\u00a0circuit\u00a0element.\n\n\nCktElement.AllVariableNames()\n \u2013 Variant\u00a0array\u00a0of\u00a0strings\u00a0listing\u00a0all\u00a0the\u00a0published\u00a0variable\u00a0names,\u00a0if\u00a0a PCElement.\u00a0Otherwise,\u00a0null\u00a0string.\n\n\nCktElement.AllVariableValues()\n \u2013 Values\u00a0of\u00a0state\u00a0variables\u00a0of\u00a0active\u00a0element if\u00a0PC\u00a0element.\n\n\nCktElement.NodeOrder()\n \u2013 Node\u00a0numbers\u00a0(representing phases,\u00a0for\u00a0example)\n\n\nCktElement.CurrentsMagAng()\n \u2013 Currents\u00a0in\u00a0magnitude,\u00a0angle\u00a0format\u00a0as\u00a0a\u00a0variant\u00a0array\u00a0of\u00a0doubles.\n\n\nCktElement.VoltagesMagAng()\n \u2013 Voltages\u00a0at\u00a0each\u00a0conductor\u00a0in\u00a0magnitude,\u00a0angle\u00a0form\u00a0as\u00a0variant array\u00a0of\u00a0doubles.\n\n\n\n\nCtrlQueue\n\n\n#\nOpenDSSDirect.DSS.CtrlQueue\n \n \nModule\n.\n\n\n\n\nmodule CtrlQueue\n \u2013 Functions for interfacing with the OpenDSS CtrlQueue.\n\n\nCtrlQueue.ClearQueue()\n \u2013 Clear the\u00a0control\u00a0queue.\n\n\nCtrlQueue.Delete()\n \u2013 Delete\u00a0a\u00a0control\u00a0action\u00a0from\u00a0the\u00a0DSS\u00a0control\u00a0queue\u00a0by\u00a0referencing\u00a0the\u00a0handle of\u00a0the\u00a0action\n\n\nCtrlQueue.NumActions()\n \u2013 Number\u00a0of\u00a0Actions\u00a0on\u00a0the\u00a0current\u00a0actionlist\u00a0(that\u00a0have\u00a0been\u00a0popped\u00a0off the\u00a0control\u00a0queue\u00a0by\u00a0CheckControlActions\n\n\nCtrlQueue.Action(arg)\n \u2013 Set\u00a0the\u00a0active\u00a0action\u00a0by\u00a0index\n\n\nCtrlQueue.ActionCode()\n \u2013 Code\u00a0for\u00a0the\u00a0active\u00a0action.\u00a0Long\u00a0integer\u00a0code\u00a0to\u00a0tell\u00a0the\u00a0control\u00a0device what\u00a0to\u00a0do.\n\n\nCtrlQueue.DeviceHandle()\n \u2013 Handle\u00a0(User\u00a0defined)\n\n\nCtrlQueue.Push()\n \u2013 Push\u00a0a\u00a0control\u00a0action\u00a0onto\u00a0the\u00a0DSS\u00a0control\u00a0queue\u00a0by\u00a0time,\u00a0action\u00a0code,\u00a0and device\u00a0handle\u00a0(user\u00a0defined).\n\n\nCtrlQueue.Show()\n \u2013 Show\u00a0the entire\u00a0control\u00a0queue\u00a0in\u00a0CSV\u00a0format\n\n\nCtrlQueue.ClearActions()\n \u2013 Clear the Action list.\n\n\nCtrlQueue.PopAction()\n \u2013 Pops\u00a0next\u00a0action\u00a0off\u00a0the\u00a0action\u00a0list\u00a0and\u00a0makes\u00a0it\u00a0the\u00a0active\u00a0action.\u00a0Returns zero\u00a0if\u00a0none.\n\n\n\n\nElement\n\n\n#\nOpenDSSDirect.DSS.Element\n \n \nModule\n.\n\n\n\n\nmodule Element\n \u2013 Functions for interfacing with the OpenDSS Elements.\n\n\nElement.NumProperties()\n \u2013 Number\u00a0of\u00a0Properties\u00a0for\u00a0the\u00a0active\u00a0DSS\u00a0object.\n\n\nElement.Name()\n \u2013 Full\u00a0Name\u00a0of\u00a0Active\u00a0DSS\u00a0Object\u00a0(general\u00a0element\u00a0or\u00a0circuit\u00a0element)\n\n\nElement.AllPropertyNames()\n \u2013 The\u00a0names\u00a0of\u00a0all\u00a0properties\u00a0for the\u00a0active\u00a0DSS\u00a0object.\n\n\n\n\nExecutive\n\n\n#\nOpenDSSDirect.DSS.Executive\n \n \nModule\n.\n\n\n\n\nmodule Executive\n \u2013 Functions for accessing DSSExecutive.\n\n\nExecutive.NumCommands()\n \u2013 Number\u00a0of\u00a0DSS\u00a0Executive\u00a0Commands\n\n\nExecutive.NumOptions()\n \u2013 Number\u00a0of\u00a0DSS\u00a0Executive\u00a0Options\n\n\nExecutive.Command(arg)\n \u2013 Get\u00a0i\u2010th\u00a0command (with i as a string)\n\n\nExecutive.Option(arg)\n \u2013 Get\u00a0i\u2010th\u00a0option (with i as a string)\n\n\nExecutive.CommandHelp(arg)\n \u2013 Get\u00a0help\u00a0string\u00a0for\u00a0i\u2010th\u00a0command (with i as a string)\n\n\nExecutive.OptionHelp(arg)\n \u2013 Get\u00a0help\u00a0string\u00a0for\u00a0i\u2010th\u00a0option (with i as a string)\n\n\nExecutive.OptionValue(arg)\n \u2013 Get\u00a0present\u00a0value\u00a0of\u00a0i\u2010th\u00a0option (with i as a string)\n\n\n\n\nFuses\n\n\n#\nOpenDSSDirect.DSS.Fuses\n \n \nModule\n.\n\n\n\n\nmodule Fuses\n \u2013 Functions for interfacing with the active OpenDSS Fuse.\n\n\nFuses.Count()\n \u2013 Number\u00a0of\u00a0Fuse\u00a0elements\u00a0in\u00a0the\u00a0circuit\n\n\nFuses.First()\n \u2013 Set\u00a0the\u00a0first\u00a0Fuse\u00a0to\u00a0be\u00a0the\u00a0active\u00a0fuse.\u00a0Returns\u00a00\u00a0if\u00a0none.\n\n\nFuses.Next()\n \u2013 Advance\u00a0the\u00a0active\u00a0Fuse\u00a0element\u00a0pointer\u00a0to\u00a0the\u00a0next\u00a0fuse.\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more fuses.\n\n\nFuses.MonitoredTerm()\n \u2013 Terminal\u00a0number\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.\n\n\nFuses.MonitoredTerm(arg)\n \u2013 Set the terminal\u00a0number\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.\n\n\nFuses.Open()\n \u2013 Manual\u00a0opening\u00a0of\u00a0fuse\n\n\nFuses.Close()\n \u2013 Close\u00a0the\u00a0fuse\u00a0back\u00a0in\u00a0and\u00a0reset.\n\n\nFuses.IsBlown()\n \u2013 Current\u00a0state\u00a0of\u00a0the\u00a0fuses.\u00a0TRUE\u00a0if\u00a0any\u00a0fuse\u00a0on\u00a0any\u00a0phase\u00a0is\u00a0blown.\u00a0Else FALSE.\n\n\nFuses.Idx()\n \u2013 Get/set\u00a0active\u00a0fuse\u00a0by\u00a0index\u00a0into\u00a0the\u00a0list\u00a0of\u00a0fuses.\u00a01\u00a0based:\u00a01..count\n\n\nFuses.Idx(arg)\n \u2013 Set\u00a0Fuse\u00a0active\u00a0by\u00a0index\u00a0into\u00a0the\u00a0list\u00a0of\u00a0fuses.\u00a01..count\n\n\nFuses.NumPhases()\n \u2013 Number\u00a0of\u00a0phases,\u00a0this\u00a0fuse.\n\n\nFuses.RatedCurrent()\n \u2013 Multiplier\u00a0or\u00a0actual\u00a0amps\u00a0for\u00a0the\u00a0TCCcurve\u00a0object.\u00a0Defaults\u00a0to\u00a01.0.\u00a0Multipliy\u00a0current\u00a0values\u00a0of\u00a0TCC\u00a0curve\u00a0by\u00a0this\u00a0to\u00a0get\u00a0actual\u00a0amps.\n\n\nFuses.RatedCurrent(arg)\n \u2013 Set the multiplier\u00a0or\u00a0actual\u00a0amps\u00a0for\u00a0the\u00a0TCCcurve\u00a0object.\u00a0Defaults\u00a0to\u00a01.0.\u00a0Multipliy\u00a0current\u00a0values\u00a0of\u00a0TCC\u00a0curve\u00a0by\u00a0this\u00a0to\u00a0get\u00a0actual\u00a0amps.\n\n\nFuses.Name()\n \u2013 Get\u00a0the\u00a0name\u00a0of\u00a0the\u00a0active\u00a0Fuse\u00a0element\n\n\nFuses.Name(arg)\n \u2013 Set\u00a0the\u00a0name\u00a0of\u00a0the\u00a0active\u00a0Fuse\u00a0element\n\n\nFuses.MonitoredObj()\n \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.\n\n\nFuses.MonitoredObj(arg)\n \u2013 Set the full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.\n\n\nFuses.SwitchedObj()\n \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0switch\u00a0that\u00a0the\u00a0fuse\u00a0controls.\u00a0Defaults\u00a0to the\u00a0MonitoredObj.\n\n\nFuses.SwitchedObj(arg)\n \u2013 Set the full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0switch\u00a0that\u00a0the\u00a0fuse\u00a0controls.\u00a0Defaults\u00a0to the\u00a0MonitoredObj.\n\n\nFuses.TCCCurve()\n \u2013 Name\u00a0of\u00a0the\u00a0TCCcurve\u00a0object\u00a0that\u00a0determines\u00a0fuse\u00a0blowing.\n\n\nFuses.TCCCurve(arg)\n \u2013 Set the name\u00a0of\u00a0the\u00a0TCCcurve\u00a0object\u00a0that\u00a0determines\u00a0fuse\u00a0blowing.\n\n\nFuses.AllNames()\n \u2013 \u00a0Names\u00a0of\u00a0all\u00a0Fuses\u00a0in\u00a0the\u00a0circuit\n\n\n\n\nGenerators\n\n\n#\nOpenDSSDirect.DSS.Generators\n \n \nModule\n.\n\n\n\n\nmodule Generators\n \u2013 Functions for interfacing with the active OpenDSS Generator.\n\n\nGenerators.First()\n \u2013 Sets\u00a0first\u00a0Generator\u00a0to\u00a0be\u00a0active.\u00a0\u00a0Returns\u00a00\u00a0if\u00a0none.\n\n\nGenerators.Next()\n \u2013 Sets\u00a0next\u00a0Generator\u00a0to\u00a0be\u00a0active.\u00a0\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more.\n\n\nGenerators.ForcedON()\n \u2013 Indicates\u00a0whether\u00a0the\u00a0generator\u00a0is\u00a0forced\u00a0ON\u00a0regardles\u00a0of\u00a0other\u00a0dispatch criteria.\n\n\nGenerators.ForcedON(arg)\n \u2013 Sets indication\u00a0whether\u00a0the\u00a0generator\u00a0is\u00a0forced\u00a0ON\u00a0regardles\u00a0of\u00a0other\u00a0dispatch criteria.\n\n\nGenerators.Phases()\n \u2013 Number of phases\n\n\nGenerators.Phases(arg)\n \u2013 Set the number\u00a0of\u00a0phases\n\n\nGenerators.Count()\n \u2013 Number\u00a0of\u00a0Generator\u00a0Objects\u00a0in\u00a0Active\u00a0Circuit\n\n\nGenerators.Idx()\n \u2013 Get/Set\u00a0active\u00a0Generator\u00a0by\u00a0index\u00a0into\u00a0generators\u00a0list.\u00a0\u00a01..Count\n\n\nGenerators.Idx(arg)\n \u2013 Set\u00a0active\u00a0Generator\u00a0by\u00a0index\u00a0into\u00a0generators\u00a0list.\u00a0\u00a01..Count\n\n\nGenerators.Model()\n \u2013 Generator model\n\n\nGenerators.Model(arg)\n \u2013 Set the Generator model\n\n\nGenerators.kV()\n \u2013 Voltage\u00a0base\u00a0for\u00a0the\u00a0active\u00a0generator,\u00a0kV\n\n\nGenerators.kV(arg)\n \u2013 Set the voltage\u00a0base\u00a0for\u00a0the\u00a0active\u00a0generator,\u00a0kV\n\n\nGenerators.kW()\n \u2013 kW\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0kvar\u00a0is\u00a0updated\u00a0for\u00a0current\u00a0power\u00a0factor.\n\n\nGenerators.kW(arg)\n \u2013 Set the kW\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0kvar\u00a0is\u00a0updated\u00a0for\u00a0current\u00a0power\u00a0factor.\n\n\nGenerators.kvar()\n \u2013 kvar\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0Updates\u00a0power\u00a0factor\u00a0based\u00a0on\u00a0present\u00a0kW value.\n\n\nGenerators.kvar(arg)\n \u2013 Set the kvar\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0Updates\u00a0power\u00a0factor\u00a0based\u00a0on\u00a0present\u00a0kW value.\n\n\nGenerators.PF()\n \u2013 Power\u00a0factor\u00a0(pos.\u00a0=\u00a0producing\u00a0vars)\n\n\nGenerators.PF(arg)\n \u2013 Set the power\u00a0factor\u00a0(pos.\u00a0=\u00a0producing\u00a0vars)\n\n\nGenerators.kVARated()\n \u2013 Get the KVA rating of the generator.\n\n\nGenerators.kVARated(arg)\n \u2013 Set the KVA rating of the generator.\n\n\nGenerators.Vmaxpu()\n \u2013 Get the Vmaxpu for Generator Model.\n\n\nGenerators.Vmaxpu(arg)\n \u2013 Set the Vmaxpu for Generator Model.\n\n\nGenerators.Vminpu()\n \u2013 Get the Vminpu for Generator Model.\n\n\nGenerators.Vminpu(arg)\n \u2013 Set the Vminpu for Generator Model.\n\n\nGenerators.Name()\n \u2013 Active generator name.\n\n\nGenerators.Name(arg)\n \u2013 Sets\u00a0a\u00a0generator\u00a0active\u00a0by\u00a0name.\n\n\nGenerators.AllNames()\n \u2013 All generator names\n\n\nGenerators.RegisterNames()\n \u2013 Array\u00a0of\u00a0Names\u00a0of\u00a0all\u00a0generator\u00a0energy\u00a0meter\u00a0registers\n\n\nGenerators.RegisterValues()\n \u2013 Array\u00a0of\u00a0valus\u00a0in\u00a0generator\u00a0energy\u00a0meter\u00a0registers.\n\n\n\n\nIsource\n\n\n#\nOpenDSSDirect.DSS.Isource\n \n \nModule\n.\n\n\n\n\nmodule Isource\n \u2013 Functions for interfacing with the active OpenDSS current source.\n\n\nIsource.Count()\n \u2013 Returns the number of Isource objects currently defined in the active circuit.\n\n\nIsource.First()\n \u2013 Set the first ISource to be active; returns 0 if none.\n\n\nIsource.Next()\n \u2013 Set the next ISource to be active; returns 0 if none.\n\n\nIsource.Amps()\n \u2013 Get the magnitude of the Isource in Amps.\n\n\nIsource.Amps(arg)\n \u2013 Set the magnitude of the Isource in Amps.\n\n\nIsource.AngleDeg()\n \u2013 Get the phase angle of the Isource in degrees.\n\n\nIsource.AngleDeg(arg)\n \u2013 Set the phase angle of the Isource in degrees.\n\n\nIsource.Frequency()\n \u2013 Get the frequency of the Isource in Hz.\n\n\nIsource.Frequency(arg)\n \u2013 Set the frequency of the Isource in Hz.\n\n\nIsource.Name()\n \u2013 Get the name of the active Isource object.\n\n\nIsource.Name(arg)\n \u2013 Set the name of the active Isource object.\n\n\nIsource.AllNames()\n \u2013 Names of all Isources in the circuit.\n\n\n\n\nLines\n\n\n#\nOpenDSSDirect.DSS.Lines\n \n \nModule\n.\n\n\n\n\nmodule Lines\n \u2013 Functions for interfacing with the active OpenDSS Line.\n\n\nLines.First()\n \u2013 Set the first element active. Returns 0 if no Lines. Otherwise, index of the line element.\n\n\nLines.Next()\n \u2013 Set the next element active. Returns 0 if no Lines. Otherwise, index of the line element.\n\n\nLines.Phases()\n \u2013 Get the number of phases of the active line object.\n\n\nLines.Phases(arg)\n \u2013 Set the number of phases of the active line object.\n\n\nLines.NumCust()\n \u2013 Get the number of customers on this line section.\n\n\nLines.Parent()\n \u2013 Get the parents of the active Line to be the active Line. Return 0 if no parent or action fails.\n\n\nLines.Count()\n \u2013 Get the number of Line Objects in Active Circuit.\n\n\nLines.Units()\n \u2013 Get the units of the line (distance, check manual for details).\n\n\nLines.Units(arg)\n \u2013 Set the units of the line (distance, check manual for details).\n\n\nLines.Length()\n \u2013 Get the length of line section in units compatible with the LineCode definition.\n\n\nLines.Length(arg)\n \u2013 Set the length of line section in units compatible with the LineCode definition.\n\n\nLines.R1()\n \u2013 Get the positive sequence resistance, ohm per unit length.\n\n\nLines.R1(arg)\n \u2013 Set the positive sequence resistance, ohm per unit length.\n\n\nLines.X1()\n \u2013 Get the positive sequence reactance, ohm per unit length.\n\n\nLines.X1(arg)\n \u2013 Set the positive sequence reactance, ohm per unit length.\n\n\nLines.R0()\n \u2013 Get the zero sequence resistance, ohm per unit length.\n\n\nLines.R0(arg)\n \u2013 Set the zero sequence resistance, ohm per unit length.\n\n\nLines.X0()\n \u2013 Get the zero sequence reactance, ohm per unit length.\n\n\nLines.X0(arg)\n \u2013 Set the zero sequence reactance, ohm per unit length.\n\n\nLines.C1()\n \u2013 Get the positive sequence capacitance, nanofarads per unit length.\n\n\nLines.C1(arg)\n \u2013 Set the positive sequence capacitance, nanofarads per unit length.\n\n\nLines.C0()\n \u2013 Get the zero sequence capacitance, nanofarads per unit length.\n\n\nLines.C0(arg)\n \u2013 Set the zero sequence capacitance, nanofarads per unit length.\n\n\nLines.NormAmps()\n \u2013 Get the normal ampere rating of Line.\n\n\nLines.NormAmps(arg)\n \u2013 Set the normal ampere rating of Line.\n\n\nLines.EmergAmps()\n \u2013 Get the emergency (maximum) ampere rating of Line.\n\n\nLines.EmergAmps(arg)\n \u2013 Set the emergency (maximum) ampere rating of Line.\n\n\nLines.Rg()\n \u2013 Get the earth return value used to compute line impedances at power frequency.\n\n\nLines.Rg(arg)\n \u2013 Set the earth return value used to compute line impedances at power frequency.\n\n\nLines.Xg()\n \u2013 Get the earth return reactance value used to compute line impedances at power frequency.\n\n\nLines.Xg(arg)\n \u2013 Set the earth return reactance value used to compute line impedances at power frequency.\n\n\nLines.Rho()\n \u2013 Get the earth resistivity, m-ohms.\n\n\nLines.Rho(arg)\n \u2013 Set the earth resistivity, m-ohms.\n\n\nLines.Name()\n \u2013 Get the name of the active Line element.\n\n\nLines.Name(arg)\n \u2013 Set the name of the Line element to set it active.\n\n\nLines.Bus1()\n \u2013 Get the name of bus for terminal 1.\n\n\nLines.Bus1(arg)\n \u2013 Set the name of bus for terminal 1.\n\n\nLines.Bus2()\n \u2013 Get the name of bus for terminal 2.\n\n\nLines.Bus2(arg)\n \u2013 Set the name of bus for terminal 2.\n\n\nLines.LineCode()\n \u2013 Get the name of LineCode object that defines the impedances.\n\n\nLines.LineCode(arg)\n \u2013 Set the name of LineCode object that defines the impedances.\n\n\nLines.Geometry()\n \u2013 Get the name of the Line geometry code.\n\n\nLines.Geometry(arg)\n \u2013 Set the name of the Line geometry code.\n\n\nLines.Spacing()\n \u2013 Get the name of the Line spacing code.\n\n\nLines.Spacing(arg)\n \u2013 Set the name of the Line spacing code.\n\n\nLines.AllNames()\n \u2013 Get the name of all Line Objects.\n\n\nLines.RMatrix()\n \u2013 Get the resistance matrix (full), ohms per unit length. Variant array of doubles.\n\n\nLines.XMatrix()\n \u2013 Get the reactance matrix (full), ohms per unit length. Variant array of doubles.\n\n\nLines.CMatrix()\n \u2013 Get the capacitance matrix (full), nanofarads per unit length. Variant array of doubles.\n\n\nLines.Yprim()\n \u2013 Get the YPrimitive of the active Line.\n\n\n\n\nLoads\n\n\n#\nOpenDSSDirect.DSS.Loads\n \n \nModule\n.\n\n\n\n\nmodule Loads\n \u2013 Functions for interfacing with the active OpenDSS load.\n\n\nLoads.First()\n \u2013 Allows to set the active load into the first load registered in the active circuit. As a result, this property will return the number 1. The parameter argument can be filled with a 0.\n\n\nLoads.Next()\n \u2013 Set the active load into the next load registered in the active circuit. As a result, this property will set the index of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Idx()\n \u2013 The index of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Idx(arg)\n \u2013 Set the index of the active load. The parameter argument must contain the index of the desired active load. The return value will be equal to 0.\n\n\nLoads.Count()\n \u2013 Returns the number of load elements within the active circuit. The parameter argument can be filled with a 0.\n\n\nLoads.Class()\n \u2013 The code number used to separate Loads by class or group. The parameter argument can be filled with a 0.\n\n\nLoads.Class(arg)\n \u2013 The code number used to separate loads by class or group. The parameter argument can be filled with a 0.\n\n\nLoads.Model()\n \u2013 The model of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Model(arg)\n \u2013 Set the model of the active load using the parameter argument. return a 0.\n\n\nLoads.NumCust()\n \u2013 The number of customer of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.NumCust(arg)\n \u2013 Set the number of customers of the active load using the parameter argument. return a 0.\n\n\nLoads.Status()\n \u2013 \n\n\nLoads.Status(arg)\n \u2013 \n\n\nLoads.IsDelta()\n \u2013 If true, loads are line to line.\n\n\nLoads.IsDelta(arg)\n \u2013 Set whether loads are delta (line to line).\n\n\nLoads.kW()\n \u2013 The kW property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kW(arg)\n \u2013 Set the kW property of the active load. The parameter argument must contain the new value in kW for the desired active load. The return value will be equal to 0.\n\n\nLoads.kV()\n \u2013 The kV property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kV(arg)\n \u2013 Set the kV property of the active load. The parameter argument must contain the new value in kV for the desired active load. The return value will be equal to 0.\n\n\nLoads.kvar()\n \u2013 The kvar property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kvar(arg)\n \u2013 Set the kvar property of the active load. The parameter argument must contain the new value in kvar for the desired active load. The return value will be equal to 0.\n\n\nLoads.PF()\n \u2013 The pf property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.PF(arg)\n \u2013 Set the pf property of the active load. The parameter argument must contain the new value in pf for the desired active load. The return value will be equal to 0.\n\n\nLoads.PctMean()\n \u2013 The PctMean property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.PctMean(arg)\n \u2013 Set the PctMean property of the active load. The parameter argument must contain the new value in PctMean for the desired active load. The return value will be equal to 0.\n\n\nLoads.PctStdDev()\n \u2013 The PctStdDev property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.PctStdDev(arg)\n \u2013 Set the PctStdDev property of the active load. The parameter argument must contain the new value in PctStdDev for the desired active load. The return value will be equal to 0.\n\n\nLoads.AllocationFactor()\n \u2013 The AllocationFactor property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.AllocationFactor(arg)\n \u2013 Set the AllocationFactor property of the active load. The parameter argument must contain the new value in AllocationFactor for the desired active load. The return value will be equal to 0.\n\n\nLoads.CFactor()\n \u2013 The CFactor property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.CFactor(arg)\n \u2013 Set the CFactor property of the active load. The parameter argument must contain the new value in CFactor for the desired active load. The return value will be equal to 0.\n\n\nLoads.CVRwatts()\n \u2013 The CVRWatts property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.CVRwatts(arg)\n \u2013 Set the CVRWatts property of the active load. The parameter argument must contain the new value in CVRWatts for the desired active load. The return value will be equal to 0.\n\n\nLoads.CVRvars()\n \u2013 The CVRvars property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.CVRvars(arg)\n \u2013 Set the CVRvars property of the active load. The parameter argument must contain the new value in CVRvars for the desired active load. The return value will be equal to 0.\n\n\nLoads.kVABase()\n \u2013 The kva property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kVABase(arg)\n \u2013 Set the kva property of the active load. The parameter argument must contain the new value in kva for the desired active load. The return value will be equal to 0.\n\n\nLoads.kWh()\n \u2013 The kWh property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kWh(arg)\n \u2013 Set the kWh property of the active load. The parameter argument must contain the new value in kWh for the desired active load. The return value will be equal to 0.\n\n\nLoads.kWhDays()\n \u2013 The kWhdays property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.kWhDays(arg)\n \u2013 Set the kWhdays property of the active load. The parameter argument must contain the new value in kWhdays for the desired active load. The return value will be equal to 0.\n\n\nLoads.Rneut()\n \u2013 The RNeut (neutral resistance for wye connected loads) property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Rneut(arg)\n \u2013 Set the RNeut (neutral resistance for wye connected loads) property of the active load. The parameter argument must contain the new value in RNeut for the desired active load. The return value will be equal to 0.\n\n\nLoads.Vmaxpu()\n \u2013 The VMaxpu property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Vmaxpu(arg)\n \u2013 Set the VMaxpu property of the active load. The parameter argument must contain the new value in VMaxpu for the desired active load. The return value will be equal to 0.\n\n\nLoads.VminEmerg()\n \u2013 The VMinemerg property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.VminEmerg(arg)\n \u2013 Set the VMinemerg property of the active load. The parameter argument must contain the new value in VMinemerg for the desired active load. The return value will be equal to 0.\n\n\nLoads.VminNorm()\n \u2013 The VMinnorm property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.VminNorm(arg)\n \u2013 Set the VMinnorm property of the active load. The parameter argument must contain the new value in VMinnorm for the desired active load. The return value will be equal to 0.\n\n\nLoads.Vminpu()\n \u2013 The VMinpu property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Vminpu(arg)\n \u2013 Set the VMinpu property of the active load. The parameter argument must contain the new value in VMinpu for the desired active load. The return value will be equal to 0.\n\n\nLoads.XfkVA()\n \u2013 The xfKVA (Rated service transformer KVA for load allocation, using Allocationfactor. Affects kW, kvar and pf.) property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.XfkVA(arg)\n \u2013 Set the xfKVA (Rated service transformer KVA for load allocation, using Allocationfactor. Affects kW, kvar and pf.) property of the active load. The parameter argument must contain the new value in xfKVA for the desired active load. The return value will be equal to 0.\n\n\nLoads.Xneut()\n \u2013 The Xneut property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.Xneut(arg)\n \u2013 Set the Xneut property of the active load. The parameter argument must contain the new value in Xneut for the desired active load. The return value will be equal to 0.\n\n\nLoads.puSeriesRL()\n \u2013 The PctSeriesRL (Percent of Load that is modeled as series R-L for harmonic studies) property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.puSeriesRL(arg)\n \u2013 Set the PctSeriesRL (Percent of Load that is modeled as series R-L for harmonic studies) property of the active load. The parameter argument must contain the new value in PctSeriesRL for the desired active load. The return value will be equal to 0.\n\n\nLoads.RelWeighting()\n \u2013 The RelWeight (relative weighting factor) property of the active load. The parameter argument can be filled with a 0.\n\n\nLoads.RelWeighting(arg)\n \u2013 Set the RelWeight (relative weighting factor) property of the active load. The parameter argument must contain the new value in RelWeight for the desired active load. The return value will be equal to 0.\n\n\nLoads.Name()\n \u2013 The Name property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Name(arg)\n \u2013 Set the active load by specifying the Name load. The parameter argument must contain the Name of the load to activate. The return value will be equal to empty.\n\n\nLoads.CVRCurve()\n \u2013 The CVRCUrve property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.CVRCurve(arg)\n \u2013 Set the CVRCurve property for the active load. The parameter argument must contain the Name of the new CVRCurve to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.Daily()\n \u2013 The daily property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Daily(arg)\n \u2013 Set the daily property for the active load. The parameter argument must contain the Name of the new daily to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.Duty()\n \u2013 The duty property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Duty(arg)\n \u2013 Set the duty property for the active load. The parameter argument must contain the Name of the new duty to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.Spectrum()\n \u2013 The Spectrum property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Spectrum(arg)\n \u2013 Set the Spectrum property for the active load. The parameter argument must contain the Name of the new Spectrum to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.Yearly()\n \u2013 The Yearly property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Yearly(arg)\n \u2013 Set the Yearly property for the active load. The parameter argument must contain the Name of the new Yearly to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.Growth()\n \u2013 The Growth property of the active load. The parameter argument can be filled with an empty string.\n\n\nLoads.Growth(arg)\n \u2013 Set the Growth property for the active load. The parameter argument must contain the Name of the new Growth to be linked to the active load. The return value will be equal to empty.\n\n\nLoads.AllNames()\n \u2013 The names of all the loads present in the active circuit. The result is delivered as variant, however, the content of this variant is an array of strings.\n\n\nLoads.ZipV()\n \u2013 The array of 7 elements (doubles) for ZIP property of the active Load object.\n\n\n\n\nLoadShape\n\n\n#\nOpenDSSDirect.DSS.LoadShape\n \n \nModule\n.\n\n\n\n\nmodule LoadShape\n \u2013 Functions for interfacing with the active OpenDSS LoadShape.\n\n\nLoadShape.Count()\n \u2013 The number of LoadShape objects currently defined in LoadShape collection.\n\n\nLoadShape.First()\n \u2013 Set the first LoadShape active and return integer index of the LoadShape. Returns 0 if no more.\n\n\nLoadShape.Next()\n \u2013 Set the next LoadShape active and return integer index of the LoadShape. Returns 0 if no more.\n\n\nLoadShape.Npts()\n \u2013 Get the number of points in active LoadShape.\n\n\nLoadShape.Npts(arg)\n \u2013 Set the number of points in active LoadShape.\n\n\nLoadShape.Normalize()\n \u2013 normalizes the P and Q curves based on either Pbase, Qbase or simply the peak value of the curve.\n\n\nLoadShape.UseActual()\n \u2013 Get a TRUE/FALSE (1/0) to let Loads know to use the actual value in the curve rather than use the value as a multiplier.\n\n\nLoadShape.UseActual(arg)\n \u2013 Set a TRUE/FALSE (1/0 - Argument) to let Loads know to use the actual value in the curve rather than use the value as a multiplier.\n\n\nLoadShape.HrInterval()\n \u2013 Get the fixed interval time value, hours.\n\n\nLoadShape.HrInterval(arg)\n \u2013 Set the fixed interval time value, hours.\n\n\nLoadShape.MinInterval()\n \u2013 Get the fixed interval time value, in minutes.\n\n\nLoadShape.MinInterval(arg)\n \u2013 Set the fixed interval time value, in minutes.\n\n\nLoadShape.PBase()\n \u2013 Get the base for normalizing P curve. If left at zero, the peak value is used.\n\n\nLoadShape.PBase(arg)\n \u2013 Set the base for normalizing P curve. If left at zero, the peak value is used.\n\n\nLoadShape.QBase()\n \u2013 Get the base for normalizing Q curve. If left at zero, the peak value is used.\n\n\nLoadShape.QBase(arg)\n \u2013 Set the base for normalizing Q curve. If left at zero, the peak value is used.\n\n\nLoadShape.SInterval()\n \u2013 Get the fixed interval data time interval, seconds.\n\n\nLoadShape.SInterval(arg)\n \u2013 Set the fixed interval data time interval, seconds.\n\n\nLoadShape.Name()\n \u2013 Get the name of the active LoadShape object.\n\n\nLoadShape.Name(arg)\n \u2013 Set the name of the active LoadShape object.\n\n\nLoadShape.AllNames()\n \u2013 Names of all of the load shapes\n\n\nLoadShape.PMult()\n \u2013 Get a variant array of doubles for the P multiplier in the LoadShape.\n\n\nLoadShape.QMult()\n \u2013 Get a variant array of doubles for the Q multiplier in the LoadShape.\n\n\nLoadShape.TimeArray()\n \u2013 Get a time array in hours corresponding to P and Q multipliers when the Interval = 0.\n\n\n\n\nMeters\n\n\n#\nOpenDSSDirect.DSS.Meters\n \n \nModule\n.\n\n\n\n\nmodule Meters\n \u2013 Functions for interfacing with the active OpenDSS energy meter.\n\n\nMeters.First()\n \u2013 Set the first Energy Meter active. Returns 0 if no Monitors.\n\n\nMeters.Next()\n \u2013 Set the next energy Meter Active. Returns 0 if no more.\n\n\nMeters.Reset()\n \u2013 Resets the active Meter object.\n\n\nMeters.ResetAll()\n \u2013 Resets all Meter object.\n\n\nMeters.Sample()\n \u2013 Causes active meter to take a sample.\n\n\nMeters.Save()\n \u2013 Causes active meter to save its current sample buffer to its meter stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.\n\n\nMeters.MeteredTerminal()\n \u2013 The number of metered terminal by the active Energy Meter.\n\n\nMeters.MeteredTerminal(arg)\n \u2013 Set the number of metered terminal by the active Energy Meter.\n\n\nMeters.DIFilesAreOpen()\n \u2013 Returns a global flag (1=true, 0=false) to indicate if Demand Interval (DI) files have been properly opened.\n\n\nMeters.SampleAll()\n \u2013 Causes all Energy Meters to take a sample of the present state. Returns 0.\n\n\nMeters.SaveAll()\n \u2013 save all Energy Meter buffers to their respective file streams. Returns 0.\n\n\nMeters.OpenAllDIFiles()\n \u2013 Opens Demand Interval (DI) files. Returns 0.\n\n\nMeters.CloseAllDIFiles()\n \u2013 Close all Demand Interval (DI) files. Necessary at the end of a run.\n\n\nMeters.CountEndElements()\n \u2013 The number of zone end elements in the active meter zone.\n\n\nMeters.Count()\n \u2013 The number of Energy Meters in the Active Circuit.\n\n\nMeters.CountBranches()\n \u2013 The number of branches in active Energy Meter zone (same as sequencelist size).\n\n\nMeters.SequenceList()\n \u2013 The index into meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be up line from later index. Sets PDElement active.\n\n\nMeters.SequenceList(arg)\n \u2013 Set the index into meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be up line from later index. Sets PDElement active.\n\n\nMeters.DoReliabilityCalc(arg)\n \u2013 calculates SAIFI, etc. if the Argument is equal to 1 assume restoration, otherwise it will not.\n\n\nMeters.SeqListSize()\n \u2013 The size of Sequence List.\n\n\nMeters.TotalCustomers()\n \u2013 The total number of customers in this zone (down line from the Energy Meter).\n\n\nMeters.NumSections()\n \u2013 The number of feeder sections in this meter's zone.\n\n\nMeters.SetActiveSection(arg)\n \u2013 Set the designated section (argument) if the index is valid.\n\n\nMeters.OCPDeviceType()\n \u2013 The type of OCP device: {1=fuse | 2+ recloser | 3= relay}.\n\n\nMeters.NumSectionCustomers()\n \u2013 The number of customers in the active section.\n\n\nMeters.NumSectionBranches()\n \u2013 The number of branches (Lines) in the active section.\n\n\nMeters.SectSeqidx()\n \u2013 The Sequence Index of the branch at the head of this section.\n\n\nMeters.SectTotalCust()\n \u2013 The total customers down line from this section.\n\n\nMeters.SAIFI()\n \u2013 SAIFI for this meter's zone. Execute reliability calc method first.\n\n\nMeters.SAIFIkW()\n \u2013 The SAIFI based on kW rather than number of customers. Get after reliability calcs.\n\n\nMeters.SAIDI()\n \u2013 The SAIDI for this meter zone. Execute DoreliabilityCalc first.\n\n\nMeters.CustInterrupts()\n \u2013 The total customer interruptions for this meter zone based on reliability calcs.\n\n\nMeters.AvgRepairTime()\n \u2013 The average Repair Time in this Section of the meter zone.\n\n\nMeters.FaultRateXRepairHrs()\n \u2013 The sum of Fault Rate time Repair Hours in this section of the meter zone.\n\n\nMeters.SumBranchFltRates()\n \u2013 The sum of the branch fault rates in this section of the meter's zone.\n\n\nMeters.Name()\n \u2013 The active Energy Meter's name.\n\n\nMeters.Name(arg)\n \u2013 Set the active Energy Meter's name.\n\n\nMeters.MeteredElement()\n \u2013 The name of the metered element (considering the active Energy Meter).\n\n\nMeters.MeteredElement(arg)\n \u2013 Set the name of the metered element (considering the active Energy Meter).\n\n\nMeters.AllNames()\n \u2013 All Energy Meter names.\n\n\nMeters.RegisterNames()\n \u2013 Strings containing the names of the registers.\n\n\nMeters.RegisterValues(arg)\n \u2013 Values contained in the Meter registers for the active Meter.\n\n\nMeters.Totals()\n \u2013 The totals for all registers of all Meters.\n\n\nMeters.PeakCurrent()\n \u2013 Returns an array of doubles with the Peak Current Property.\n\n\nMeters.CalcCurrent()\n \u2013 The magnitude of the real part of the Calculated Current (normally determined by solution) for the meter to force some behavior on Load Allocation.\n\n\nMeters.AllocFactors()\n \u2013 An array of doubles: allocation factors for the active Meter.\n\n\nMeters.AllEndElements()\n \u2013 A vector of names of all zone end elements.\n\n\nMeters.AllBranchesInZone()\n \u2013 A wide string list of all branches in zone of the active Energy Meter object.\n\n\n\n\nMonitors\n\n\n#\nOpenDSSDirect.DSS.Monitors\n \n \nModule\n.\n\n\n\n\nmodule Monitors\n \u2013 Functions for interfacing with the active OpenDSS Monitor.\n\n\nMonitors.First()\n \u2013 Set the first monitor active. Returns 0 if no Monitors.\n\n\nMonitors.Next()\n \u2013 Set the next monitor active. Returns 0 if no more.\n\n\nMonitors.Reset()\n \u2013 Resets the active Monitor object.\n\n\nMonitors.ResetAll()\n \u2013 Resets all Monitor object.\n\n\nMonitors.Sample()\n \u2013 Causes active monitor to take a sample.\n\n\nMonitors.Save()\n \u2013 Causes active monitor to save its current sample buffer to its monitor stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.\n\n\nMonitors.Show()\n \u2013 Converts monitor file into text and displays with text editor.\n\n\nMonitors.Mode()\n \u2013 The monitor mode (bitmask integer - see DSS Help).\n\n\nMonitors.Mode(arg)\n \u2013 Set the monitor mode (bitmask integer - see DSS Help).\n\n\nMonitors.SampleCount()\n \u2013 Returns number of samples in Monitor at present.\n\n\nMonitors.SampleAll()\n \u2013 Causes all Monitors to take a sample of the present state. Returns 0.\n\n\nMonitors.SaveAll()\n \u2013 Save all Monitor buffers to their respective file streams. Returns 0.\n\n\nMonitors.Count()\n \u2013 The number of Monitors.\n\n\nMonitors.Process()\n \u2013 Post-process monitor samples taken so far, e.g., Pst for mode = 4.\n\n\nMonitors.ProcessAll()\n \u2013 Makes that all Monitors post-process the data taken so far.\n\n\nMonitors.FileVersion()\n \u2013 The Monitor File version (integer).\n\n\nMonitors.RecordSize()\n \u2013 The size of each record in ByteStream.\n\n\nMonitors.NumChannels()\n \u2013 The number of Channels on the active Monitor.\n\n\nMonitors.Terminal()\n \u2013 The terminal number of element being monitored.\n\n\nMonitors.Terminal(arg)\n \u2013 Set the terminal number of element being monitored.\n\n\nMonitors.FileName()\n \u2013 The name of the CSV file associated with active monitor.\n\n\nMonitors.Name()\n \u2013 The active Monitor object by name.\n\n\nMonitors.Name(arg)\n \u2013 Set the active Monitor object by name.\n\n\nMonitors.Element()\n \u2013 The full name of element being monitored by the active Monitor.\n\n\nMonitors.Element(arg)\n \u2013 Set the full name of element being monitored by the active Monitor.\n\n\nMonitors.AllNames()\n \u2013 An array of all Monitor names (array of strings).\n\n\nMonitors.ByteStream()\n \u2013 \"A byte array containing monitor stream values. Make sure a \" * @save_str(\" is done first (standard solution modes do this automatically).\")\n\n\nMonitors.DblHourS()\n \u2013 The header string; vector of strings containing Channel Names.\n\n\nMonitors.DblHour()\n \u2013 A vector of doubles containing time value in hours for the time-sampled monitor values; empty if frequency-sampled values for harmonics solution (see dblFreq).\n\n\nMonitors.DblFreqS()\n \u2013 A vector of doubles containing time values for harmonics mode solutions; empty for time mode solutions (use dblHour).\n\n\nMonitors.DblFreq()\n \u2013 A vector of doubles for the specified channel (usage: MyArray = DSSmonitor.Channel(i)) A save or SaveAll should be executed first. Done automatically by most standard solution modes.\n\n\n\n\nParser\n\n\n#\nOpenDSSDirect.DSS.Parser\n \n \nModule\n.\n\n\n\n\nmodule Parser\n \u2013 Functions for interfacing with the OpenDSS Parser.\n\n\nParser.IntValue()\n \u2013 Return next parameter as a long integer.\n\n\nParser.ResetDelimiters()\n \u2013 Reset delimiters to their default values.\n\n\nParser.AutoIncrement()\n \u2013 In the default is false (0). If true (1) Parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.\n\n\nParser.AutoIncrement(arg)\n \u2013 In the default is false (0). If true (1) Parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.\n\n\nParser.DblValue()\n \u2013 Returns next parameter as a double.\n\n\nParser.CmdString()\n \u2013 Get a string to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.\n\n\nParser.CmdString(arg)\n \u2013 Set a string to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.\n\n\nParser.NextParam()\n \u2013 Get next token and return tag name (before = sign) if any. See Autoincrement.\n\n\nParser.StrValue()\n \u2013 Return next parameter as a string.\n\n\nParser.WhiteSpace()\n \u2013 Get the characters used for White space in the command string. Default in blank and Tab.\n\n\nParser.WhiteSpace(arg)\n \u2013 Set the characters used for White space in the command string. Default in blank and Tab.\n\n\nParser.BeginQuote()\n \u2013 Get the string containing the characters for quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"([{.\n\n\nParser.BeginQuote(arg)\n \u2013 Set the string containing the characters for quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"([{.\n\n\nParser.EndQuote()\n \u2013 Get the string containing the characters, in order, that match the beginning quote characters in BeginQuote. Default is \")]}.\n\n\nParser.EndQuote(arg)\n \u2013 Set the string containing the characters, in order, that match the beginning quote characters in BeginQuote. Default is \")]}.\n\n\nParser.Delimiters()\n \u2013 Get the string defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitespace to separate tokens.\n\n\nParser.Delimiters(arg)\n \u2013 Set the string defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitespace to separate tokens.\n\n\nParser.Vector()\n \u2013 Returns token as vector of doubles. For parsing quoted array syntax.\n\n\nParser.Matrix()\n \u2013 Use this property to parse a Matrix token in OpenDSS format. Returns square matrix of order specified. Order same as default fortran order: column by column.\n\n\nParser.SymMatrix()\n \u2013 Use this property to parse a Matrix token in lower triangular form. Symmetry is forced.\n\n\n\n\nPDElements\n\n\n#\nOpenDSSDirect.DSS.PDElements\n \n \nModule\n.\n\n\n\n\nmodule PDElements\n \u2013 Functions for interfacing with the active OpenDSS power-delivery element.\n\n\nPDElements.Count()\n \u2013 Get number of PDElements in active circuit.\n\n\nPDElements.First()\n \u2013 Set the first enabled PD element to be the active element. Returns 0 if none found.\n\n\nPDElements.Next()\n \u2013 Set the next enabled PD element to be the active element. Returns 0 if none found.\n\n\nPDElements.IsShunt()\n \u2013 returns 1 if the PD element should be treated as a shunt element rather than a series element. Applies to capacitor and reactor elements in particular.\n\n\nPDElements.NumCustomers()\n \u2013 Get the number of customers in this branch.\n\n\nPDElements.TotalCustomers()\n \u2013 Get the total number of customers from this branch to the end of the zone.\n\n\nPDElements.ParentPDElement()\n \u2013 Set the parent PD element to be the active circuit element. Returns 0 if no more elements upline.\n\n\nPDElements.FromTerminal()\n \u2013 \"Get the number of the terminal of active PD element that is on the \" * @from_str(\" side. This is set after the meter zone is determined.\")\n\n\nPDElements.SectionID()\n \u2013 Get the integer ID of the feeder section that this PDElement branch is part of.\n\n\nPDElements.FaultRate()\n \u2013 Get the number of failures per year. For LINE elements: Number of failures per unit length per year.\n\n\nPDElements.FaultRate(arg)\n \u2013 Set the number of failures per year. For LINE elements: Number of failures per unit length per year.\n\n\nPDElements.PctPermanent()\n \u2013 Get the percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.\n\n\nPDElements.PctPermanent(arg)\n \u2013 Set the percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.\n\n\nPDElements.Lambda()\n \u2013 Get the failure rate for this branch. Faults per year including length of line.\n\n\nPDElements.AccumulatedL()\n \u2013 Get the accumulated failure rate for this branch on down line.\n\n\nPDElements.RepairTime()\n \u2013 Get the average time to repair a permanent fault on this branch, hours.\n\n\nPDElements.TotalMiles()\n \u2013 Get the total miles of line from this element to the end of the zone. For recloser siting algorithm.\n\n\nPDElements.Name()\n \u2013 Get the name of the active PDElement, returns null string if active element id not PDElement.\n\n\nPDElements.Name(arg)\n \u2013 Set the name of the active PDElement, returns null string if active element id not PDElement.\n\n\n\n\nProgress\n\n\n#\nOpenDSSDirect.DSS.Progress\n \n \nModule\n.\n\n\n\n\nmodule Progress\n \u2013 Functions for controlling the progress form.\n\n\nProgress.PctProgress()\n \u2013 Percent\u00a0Progress\u00a0to\u00a0indicate\u00a0[0..100]\n\n\nProgress.Show()\n \u2013 Shows\u00a0Progress\u00a0form\u00a0with\u00a0null\u00a0caption\u00a0and\u00a0Progress\u00a0set\u00a0to\u00a0zero.\n\n\nProgress.Close()\n \u2013 Close the Progress form.\n\n\nProgress.Caption()\n \u2013 Caption\u00a0to\u00a0appear\u00a0on\u00a0the\u00a0bottom\u00a0of\u00a0the\u00a0DSS\u00a0Progress\u00a0form.\n\n\n\n\nProperties\n\n\n#\nOpenDSSDirect.DSS.Properties\n \n \nModule\n.\n\n\n\n\nmodule Properties\n \u2013 Functions for interfacing with OpenDSS properties.\n\n\nProperties.Name()\n \u2013 The name of the active property.\n\n\nProperties.Description()\n \u2013 The description of the active property.\n\n\nProperties.Value()\n \u2013 The value of the active property.\n\n\nProperties.Value(arg)\n \u2013 Set the value of the active property. The new value must be specified in \narg\n as a string.\n\n\n\n\nPVsystems\n\n\n#\nOpenDSSDirect.DSS.PVsystems\n \n \nModule\n.\n\n\n\n\nmodule PVsystems\n \u2013 Functions for interfacing with the active OpenDSS PVsystem.\n\n\nPVsystems.Count()\n \u2013 The number of PVSystem objects currently defined in the active circuit.\n\n\nPVsystems.First()\n \u2013 Set the first PVSystem to be active; returns 0 if none.\n\n\nPVsystems.Next()\n \u2013 Set the next PVSystem to be active; returns 0 if none.\n\n\nPVsystems.Idx()\n \u2013 Get the active PVSystem by index; 1..Count.\n\n\nPVsystems.Idx(arg)\n \u2013 Set the active PVSystem by index; 1..Count.\n\n\nPVsystems.Irradiance()\n \u2013 Get the present value of the Irradiance property in W/sq-m.\n\n\nPVsystems.Irradiance(arg)\n \u2013 Set the present value of the Irradiance property in W/sq-m.\n\n\nPVsystems.kW()\n \u2013 Get the kW output.\n\n\nPVsystems.kvar()\n \u2013 Get the kvar value.\n\n\nPVsystems.kvar(arg)\n \u2013 Set the kvar value.\n\n\nPVsystems.pf()\n \u2013 Get the power factor value.\n\n\nPVsystems.pf(arg)\n \u2013 Set the power factor value.\n\n\nPVsystems.kVARated()\n \u2013 Get the rated kVA.\n\n\nPVsystems.kVARated(arg)\n \u2013 Set the rated kVA.\n\n\n\n\nReclosers\n\n\n#\nOpenDSSDirect.DSS.Reclosers\n \n \nModule\n.\n\n\n\n\nmodule Reclosers\n \u2013 Functions for interfacing with the active OpenDSS Recloser.\n\n\nReclosers.Count()\n \u2013 Get number of Reclosers in active circuit.\n\n\nReclosers.First()\n \u2013 Set first recloser to be active Circuit Element. Returns 0 if none.\n\n\nReclosers.Next()\n \u2013 Set next recloser to be active Circuit Element. Returns 0 if none.\n\n\nReclosers.MonitoredTerm()\n \u2013 Get the terminal number of Monitored Object for the Recloser.\n\n\nReclosers.MonitoredTerm(arg)\n \u2013 Set the terminal number of Monitored Object for the Recloser.\n\n\nReclosers.SwitchedTerm()\n \u2013 Get the terminal of the controlled device being switched by the Recloser.\n\n\nReclosers.SwitchedTerm(arg)\n \u2013 Set the terminal of the controlled device being switched by the Recloser.\n\n\nReclosers.NumFast()\n \u2013 Get the number of fast shots.\n\n\nReclosers.NumFast(arg)\n \u2013 Set the number of fast shots.\n\n\nReclosers.Shots()\n \u2013 Get the number of shots to lockout (fast + delayed).\n\n\nReclosers.Shots(arg)\n \u2013 Set the number of shots to lockout (fast + delayed).\n\n\nReclosers.Open()\n \u2013 Open recloser's controlled element and lock out the recloser.\n\n\nReclosers.Close()\n \u2013 Close the switched object controlled by the recloser. Resets recloser to first operation.\n\n\nReclosers.Idx()\n \u2013 Get the active recloser by index into the recloser list. 1..Count.\n\n\nReclosers.Idx(arg)\n \u2013 Set the active recloser by index into the recloser list. 1..Count.\n\n\nReclosers.PhaseTrip()\n \u2013 Get the phase trip curve multiplier or actual amps.\n\n\nReclosers.PhaseTrip(arg)\n \u2013 Set the phase trip curve multiplier or actual amps.\n\n\nReclosers.PhaseInst()\n \u2013 Get the phase instantaneous curve multiplier or actual amps.\n\n\nReclosers.PhaseInst(arg)\n \u2013 Set the phase instantaneous curve multiplier or actual amps.\n\n\nReclosers.GroundTrip()\n \u2013 Get the ground (3I0) trip multiplier or actual amps.\n\n\nReclosers.GroundTrip(arg)\n \u2013 Set the ground (3I0) trip multiplier or actual amps.\n\n\nReclosers.GroundInst()\n \u2013 Get the ground (3I0) instantaneous trip setting - curve multiplier or actual amps.\n\n\nReclosers.GroundInst(arg)\n \u2013 Set the ground (3I0) instantaneous trip setting - curve multiplier or actual amps.\n\n\nReclosers.Name()\n \u2013 Get the name of the active Recloser Object.\n\n\nReclosers.Name(arg)\n \u2013 Set the name of the active Recloser Object.\n\n\nReclosers.MonitoredObj()\n \u2013 Get the full name of object this Recloser is monitoring.\n\n\nReclosers.MonitoredObj(arg)\n \u2013 Set the full name of object this Recloser is monitoring.\n\n\nReclosers.SwitchedObj()\n \u2013 Get the full name of the circuit element that is being switched by this Recloser.\n\n\nReclosers.SwitchedObj(arg)\n \u2013 Set the full name of the circuit element that is being switched by this Recloser.\n\n\nReclosers.AllNames()\n \u2013 Get a vector of strings with names of all Reclosers in active circuit.\n\n\nReclosers.RecloseIntervals()\n \u2013 Get a vector of doubles: reclose intervals (s) between shots.\n\n\n\n\nRegControls\n\n\n#\nOpenDSSDirect.DSS.RegControls\n \n \nModule\n.\n\n\n\n\nmodule RegControls\n \u2013 Functions for interfacing with the active OpenDSS RegControl.\n\n\nRegControls.First()\n \u2013 Set the first RegControl active. Returns 0 if no more.\n\n\nRegControls.Next()\n \u2013 Set the next RegControl active. Returns 0 if no more\n\n\nRegControls.TapWinding()\n \u2013 Get the tapped winding number.\n\n\nRegControls.TapWinding(arg)\n \u2013 Set the tapped winding number.\n\n\nRegControls.Winding()\n \u2013 Get the winding number for PT and CT connections.\n\n\nRegControls.Winding(arg)\n \u2013 Set the winding number for PT and CT connections.\n\n\nRegControls.IsReversible()\n \u2013 Get the setting in the reverse direction, usually not applicable to substation Transformers.\n\n\nRegControls.IsReversible(arg)\n \u2013 Set the different settings for the reverse direction (see Manual for details), usually not applicable to substation Transformers.\n\n\nRegControls.IsInverseTime()\n \u2013 Get the inverse time feature. Time delay is inversely adjusted, proportional to the amount of voltage outside the regulator band.\n\n\nRegControls.IsInverseTime(arg)\n \u2013 Set the inverse time feature. Time delay is inversely adjusted, proportional to the amount of voltage outside the regulator band.\n\n\nRegControls.MaxTapChange()\n \u2013 Get the maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for faster solution.\n\n\nRegControls.MaxTapChange(arg)\n \u2013 Set the maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for faster solution.\n\n\nRegControls.Count()\n \u2013 Get the number of RegControl objects in Active Circuit.\n\n\nRegControls.TapNumber()\n \u2013 Get the tap number.\n\n\nRegControls.TapNumber(arg)\n \u2013 Set the tap number.\n\n\nRegControls.CTPrimary()\n \u2013 Get the CT primary ampere rating (secondary is 0.2 amperes).\n\n\nRegControls.CTPrimary(arg)\n \u2013 Set the CT primary ampere rating (secondary is 0.2 amperes).\n\n\nRegControls.PTRatio()\n \u2013 Get the PT ratio for voltage control settings.\n\n\nRegControls.PTRatio(arg)\n \u2013 Set the PT ratio for voltage control settings.\n\n\nRegControls.ForwardR()\n \u2013 Get the LDC R settings in Volts.\n\n\nRegControls.ForwardR(arg)\n \u2013 Set the LDC R settings in Volts.\n\n\nRegControls.ForwardX()\n \u2013 Get the LDC X settings in Volts.\n\n\nRegControls.ForwardX(arg)\n \u2013 Set the LDC X settings in Volts.\n\n\nRegControls.ReverseR()\n \u2013 Get the reverse LDC R settings in Volts.\n\n\nRegControls.ReverseR(arg)\n \u2013 Set the reverse LDC R settings in Volts.\n\n\nRegControls.ReverseX()\n \u2013 Get the reverse LDC X settings in Volts.\n\n\nRegControls.ReverseX(arg)\n \u2013 Set the reverse LDC X settings in Volts.\n\n\nRegControls.Delay()\n \u2013 Get the time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\n\n\nRegControls.Delay(arg)\n \u2013 Set the time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\n\n\nRegControls.TapDelay()\n \u2013 Get the time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\n\n\nRegControls.TapDelay(arg)\n \u2013 Set the time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\n\n\nRegControls.VoltageLimit()\n \u2013 Get the first house voltage limit on PT secondary base. Setting to 0 disables this function.\n\n\nRegControls.VoltageLimit(arg)\n \u2013 Set the first house voltage limit on PT secondary base. Setting to 0 disables this function.\n\n\nRegControls.ForwardBand()\n \u2013 Get the regulation bandwidth in forward direction, centered on Vreg.\n\n\nRegControls.ForwardBand(arg)\n \u2013 Set the regulation bandwidth in forward direction, centered on Vreg.\n\n\nRegControls.ForwardVreg()\n \u2013 Get the target voltage in the forward direction, on PT secondary base.\n\n\nRegControls.ForwardVreg(arg)\n \u2013 Set the target voltage in the forward direction, on PT secondary base.\n\n\nRegControls.ReverseBand()\n \u2013 Get the bandwidth in reverse direction, centered on reverse Vreg.\n\n\nRegControls.ReverseBand(arg)\n \u2013 Set the bandwidth in reverse direction, centered on reverse Vreg.\n\n\nRegControls.ReverseVreg()\n \u2013 Get the target voltage in the reverse direction, on PT secondary base.\n\n\nRegControls.ReverseVreg(arg)\n \u2013 Set the target voltage in the reverse direction, on PT secondary base.\n\n\nRegControls.Name()\n \u2013 Get the active RegControl name.\n\n\nRegControls.Name(arg)\n \u2013 Set the active RegControl name.\n\n\nRegControls.MonitoredBus()\n \u2013 Get the name of the remote regulated bus, in lieu of LDC settings.\n\n\nRegControls.MonitoredBus(arg)\n \u2013 Set the name of the remote regulated bus, in lieu of LDC settings.\n\n\nRegControls.Transformer()\n \u2013 Get the name of the transformer this regulator controls.\n\n\nRegControls.Transformer(arg)\n \u2013 Set the name of the transformer this regulator controls.\n\n\nRegControls.AllNames()\n \u2013 Get a vector of strings containing all RegControl names.\n\n\n\n\nRelays\n\n\n#\nOpenDSSDirect.DSS.Relays\n \n \nModule\n.\n\n\n\n\nmodule Relays\n \u2013 Functions for interfacing with the active OpenDSS Relay.\n\n\nRelays.Count()\n \u2013 Get number of Relays in active circuit.\n\n\nRelays.First()\n \u2013 Set first relay active. If none, returns 0.\n\n\nRelays.Next()\n \u2013 Set next relay active. If none, returns 0.\n\n\nRelays.MonitoredTerm()\n \u2013 Get the number of terminal of monitored element that this relay is monitoring.\n\n\nRelays.MonitoredTerm(arg)\n \u2013 Set the number of terminal of monitored element that this relay is monitoring.\n\n\nRelays.SwitchedTerm()\n \u2013 Get the number of terminal of the switched object that will be opened when the relay trips.\n\n\nRelays.SwitchedTerm(arg)\n \u2013 Set the number of terminal of the switched object that will be opened when the relay trips.\n\n\nRelays.Idx()\n \u2013 Get the active relay by index into the Relay list. 1..Count.\n\n\nRelays.Idx(arg)\n \u2013 Set the active relay by index into the Relay list. 1..Count.\n\n\nRelays.Name()\n \u2013 Get the name of the active Relay.\n\n\nRelays.Name(arg)\n \u2013 Set the name of the active Relay.\n\n\nRelays.MonitoredObj()\n \u2013 Get the full name of the object this relay is monitoring.\n\n\nRelays.MonitoredObj(arg)\n \u2013 Set the full name of the object this relay is monitoring.\n\n\nRelays.SwitchedObj()\n \u2013 Get the full name of element that will switched when relay trips.\n\n\nRelays.SwitchedObj(arg)\n \u2013 Set the full name of element that will switched when relay trips.\n\n\nRelays.AllNames()\n \u2013 Get a vector of strings containing names of all relay elements.\n\n\n\n\nSensors\n\n\n#\nOpenDSSDirect.DSS.Sensors\n \n \nModule\n.\n\n\n\n\nmodule Sensors\n \u2013 Functions for interfacing with the active OpenDSS Sensor.\n\n\nSensors.Count()\n \u2013 Get number of Sensors in active circuit.\n\n\nSensors.First()\n \u2013 Set the first sensor active. Returns 0 if none.\n\n\nSensors.Next()\n \u2013 Set the next sensor active. Returns 0 if none\n\n\nSensors.IsDelta()\n \u2013 Returns 1 if the sensor is connected in delta; otherwise, returns 0.\n\n\nSensors.IsDelta(arg)\n \u2013 Allows to set 1 if the sensor is connected in delta; otherwise, set 0 (argument).\n\n\nSensors.ReverseDelta()\n \u2013 Returns 1 if voltage measurements are 1-3, 3-2, 2-1; otherwise 0.\n\n\nSensors.ReverseDelta(arg)\n \u2013 Allows to set 1 if voltage measurements are 1-3, 3-2, 2-1; otherwise 0.\n\n\nSensors.MeteredTerminal()\n \u2013 Get the number of the measured terminal in the measured element.\n\n\nSensors.MeteredTerminal(arg)\n \u2013 Set the number of the measured terminal in the measured element.\n\n\nSensors.Reset()\n \u2013 Clears the active sensor.\n\n\nSensors.ResetAll()\n \u2013 Clears all Sensors in the active circuit.\n\n\nSensors.PctError()\n \u2013 Get the assumed percent error in the Sensor measurement. Default is 1.\n\n\nSensors.PctError(arg)\n \u2013 Set the assumed percent error in the Sensor measurement. Default is 1.\n\n\nSensors.Weight()\n \u2013 Get the weighting factor for this sensor measurement with respect to the other Sensors. Default is 1.\n\n\nSensors.Weight(arg)\n \u2013 Set the weighting factor for this sensor measurement with respect to the other Sensors. Default is 1.\n\n\nSensors.kVBase()\n \u2013 Get the voltage base for the sensor measurements. LL for 2 and 3 - phase Sensors, LN for 1-phase Sensors.\n\n\nSensors.kVBase(arg)\n \u2013 Set the voltage base for the sensor measurements. LL for 2 and 3 - phase Sensors, LN for 1-phase Sensors.\n\n\nSensors.Name()\n \u2013 Get the name of the active sensor object.\n\n\nSensors.Name(arg)\n \u2013 Set the name of the active sensor object.\n\n\nSensors.MeteredElement()\n \u2013 Get the full name of the measured element.\n\n\nSensors.MeteredElement(arg)\n \u2013 Set the full name of the measured element.\n\n\nSensors.AllNames()\n \u2013 Returns a vector of sensor names.\n\n\nSensors.Currents()\n \u2013 Get an array of doubles for the line current measurements; don't use with KWS and KVARS.\n\n\nSensors.kvar()\n \u2013 Get an array of doubles for Q measurements; overwrites currents with a new estimate using KWS.\n\n\nSensors.kW()\n \u2013 Get an array of doubles for P measurements; overwrites currents with a new estimate using KVARS.\n\n\n\n\nSettings\n\n\n#\nOpenDSSDirect.DSS.Settings\n \n \nModule\n.\n\n\n\n\nmodule Settings\n \u2013 Functions for controlling global OpenDSS settings.\n\n\nSettings.AllowDuplicates()\n \u2013 Get if OpenDSS allows duplicate names of objects: {1 allow, 0 not allow}.\n\n\nSettings.AllowDuplicates(arg)\n \u2013 Set if OpenDSS allows duplicate names of objects: {1 allow, 0 not allow}.\n\n\nSettings.ZoneLock()\n \u2013 Get the status of Lock zones on energy Meters to prevent rebuilding if a circuit change occurs: {1= true, 0= False}.\n\n\nSettings.ZoneLock(arg)\n \u2013 Set the status of Lock zones on energy Meters to prevent rebuilding if a circuit change occurs: {1= true, 0= False}.\n\n\nSettings.CktModel()\n \u2013 Get {dssMultiphase* | dssPositiveSeq} Indicate if the circuit model is positive sequence.\n\n\nSettings.CktModel(arg)\n \u2013 Set {dssMultiphase* | dssPositiveSeq} Indicate if the circuit model is positive sequence.\n\n\nSettings.Trapezoidal()\n \u2013 Get {True (1) | False (0)} value of trapezoidal integration flag in Energy Meters.\n\n\nSettings.Trapezoidal(arg)\n \u2013 Set {True (1) | False (0)} value of trapezoidal integration flag in Energy Meters.\n\n\nSettings.AllocationFactors(arg)\n \u2013 Set all load allocation factors for all loads defined by XFKVA property to this value.\n\n\nSettings.NormVminpu()\n \u2013 Get the per unit minimum voltage for Normal conditions.\n\n\nSettings.NormVminpu(arg)\n \u2013 Set the per unit minimum voltage for Normal conditions.\n\n\nSettings.NormVmaxpu()\n \u2013 Get the per unit maximum voltage for Normal conditions.\n\n\nSettings.NormVmaxpu(arg)\n \u2013 Set the per unit maximum voltage for Normal conditions.\n\n\nSettings.EmergVminpu()\n \u2013 Get the per unit minimum voltage for Emergency conditions.\n\n\nSettings.EmergVminpu(arg)\n \u2013 Set the per unit minimum voltage for Emergency conditions.\n\n\nSettings.EmergVmaxpu()\n \u2013 Get the per unit maximum voltage for Emergency conditions.\n\n\nSettings.EmergVmaxpu(arg)\n \u2013 Set the per unit maximum voltage for Emergency conditions.\n\n\nSettings.UEWeight()\n \u2013 Get the weighting factor applied to UE register values.\n\n\nSettings.UEWeight(arg)\n \u2013 Set the weighting factor applied to UE register values.\n\n\nSettings.LossWeight()\n \u2013 Get the weighting factor applied to Loss register values.\n\n\nSettings.LossWeight(arg)\n \u2013 Set the weighting factor applied to Loss register values.\n\n\nSettings.PriceSignal()\n \u2013 Get the price signal for the circuit.\n\n\nSettings.PriceSignal(arg)\n \u2013 Set the price signal for the circuit.\n\n\nSettings.AutoBusList()\n \u2013 Get the list of Buses or (File=xxxxx) syntax for the AutoAdd solution mode.\n\n\nSettings.AutoBusList(arg)\n \u2013 Set the list of Buses or (File=xxxxx) syntax for the AutoAdd solution mode.\n\n\nSettings.PriceCurve()\n \u2013 Get the name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\n\n\nSettings.PriceCurve(arg)\n \u2013 Set the name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\n\n\nSettings.UERegs()\n \u2013 Get the array of Integers defining Energy Meter registers to use for computing UE.\n\n\nSettings.LossRegs()\n \u2013 Get the array of Integers defining Energy Meter registers to use for computing Losses.\n\n\nSettings.VoltageBases()\n \u2013 Get the array of doubles defining the legal voltage bases in kV L-L.\n\n\n\n\nSolution\n\n\n#\nOpenDSSDirect.DSS.Solution\n \n \nModule\n.\n\n\n\n\nmodule Solution\n \u2013 Functions for controlling OpenDSS solutions.\n\n\nSolution.Solve()\n \u2013 Executes the solution for the present solution mode. Returns 0.\n\n\nSolution.Mode()\n \u2013 The present solution mode (See DSS help).\n\n\nSolution.Mode(arg)\n \u2013 Modifies the present solution mode (See DSS help).\n\n\nSolution.Hour()\n \u2013 The present hour (See DSS help).\n\n\nSolution.Hour(arg)\n \u2013 Modifies the present hour (See DSS help).\n\n\nSolution.Year()\n \u2013 The present Year (See DSS help).\n\n\nSolution.Year(arg)\n \u2013 Modifies the present Year (See DSS help).\n\n\nSolution.Iterations()\n \u2013 Return the number of iterations taken for the last solution.\n\n\nSolution.MaxIterations()\n \u2013 The Maximum number of iterations used to solve the circuit.\n\n\nSolution.MaxIterations(arg)\n \u2013 Modifies the Maximum number of iterations used to solve the circuit.\n\n\nSolution.Number()\n \u2013 The number of solutions to perform for MonteCarlo and time series simulations.\n\n\nSolution.Number(arg)\n \u2013 Modifies the number of solutions to perform for MonteCarlo and time series simulations.\n\n\nSolution.Random()\n \u2013 \"The randomization mode for random variables \" * (@Gaussian_str(\" o \",\"Uniform\") * \".\")\n\n\nSolution.Random(arg)\n \u2013 \"Modifies the randomization mode for random variables \" * (@Gaussian_str(\" o \",\"Uniform\") * \".\")\n\n\nSolution.LoadModel()\n \u2013 The Load Model: {dssPowerFlow (default)|dssAdmittance}.\n\n\nSolution.LoadModel(arg)\n \u2013 Modifies the Load Model: {dssPowerFlow (default)|dssAdmittance}.\n\n\nSolution.AddType()\n \u2013 The type of device to add in AutoAdd Mode: {dssGen (default)|dssCap}.\n\n\nSolution.AddType(arg)\n \u2013 Modifies the type of device to add in AutoAdd Mode: {dssGen (default)|dssCap}.\n\n\nSolution.Algorithm()\n \u2013 The base solution algorithm: {dssNormalSolve | dssNewtonSolve}.\n\n\nSolution.Algorithm(arg)\n \u2013 Modifies the base solution algorithm: {dssNormalSolve | dssNewtonSolve}.\n\n\nSolution.ControlMode()\n \u2013 The mode for control devices: {dssStatic (default) | dssEvent | dssTime}.\n\n\nSolution.ControlMode(arg)\n \u2013 Modifies the mode for control devices: {dssStatic (default) | dssEvent | dssTime}.\n\n\nSolution.ControlIterations()\n \u2013 The current value of the control iteration counter.\n\n\nSolution.ControlIterations(arg)\n \u2013 Modifies the current value of the control iteration counter.\n\n\nSolution.MaxControlIterations()\n \u2013 The maximum allowable control iterations.\n\n\nSolution.MaxControlIterations(arg)\n \u2013 Modifies the maximum allowable control iterations.\n\n\nSolution.SampleDoControlActions()\n \u2013 Sample controls and then process the control queue for present control mode and dispatch control actions. Returns 0.\n\n\nSolution.CheckFaultStatus()\n \u2013 Executes status check on all fault objects defined in the circuit. Returns 0.\n\n\nSolution.SolveDirect()\n \u2013 Executes a direct solution from the system Y matrix, ignoring compensation currents of loads, generators (includes Yprim only).\n\n\nSolution.SolvePFlow()\n \u2013 Solves using present power flow method. Iterative solution rather than direct solution.\n\n\nSolution.SolveNoControl()\n \u2013 Is similar to SolveSnap except no control actions are checked or executed.\n\n\nSolution.SolvePlusControl()\n \u2013 Executes a power flow solution (SolveNoControl) plus executes a CheckControlActions that executes any pending control actions.\n\n\nSolution.InitSnap()\n \u2013 Initializes some variables for snap shot power flow. SolveSnap does this automatically.\n\n\nSolution.CheckControls()\n \u2013 Performs the normal process for sampling and executing Control Actions and Fault Status and rebuilds Y if necessary.\n\n\nSolution.SampleControlDevices()\n \u2013 Executes a sampling of all intrinsic control devices, which push control actions into the control queue.\n\n\nSolution.DoControlActions()\n \u2013 Pops control actions off the control queue and dispatches to the proper control element.\n\n\nSolution.BuildYMatrix()\n \u2013 Forces building of the System Y matrix according to the argument: {1= series elements only | 2= Whole Y matrix}.\n\n\nSolution.SystemYChanged()\n \u2013 Indicates if elements of the System Y have been changed by recent activity. If changed returns 1; otherwise 0.\n\n\nSolution.Converged()\n \u2013 Indicates whether the circuit solution converged (1 converged | 0 not converged).\n\n\nSolution.Converged(arg)\n \u2013 Modifies the converged flag (1 converged | 0 not converged).\n\n\nSolution.TotalIterations()\n \u2013 The total iterations including control iterations for most recent solution.\n\n\nSolution.MostIterationsDone()\n \u2013 The max number of iterations required to converge at any control iteration of the most recent solution.\n\n\nSolution.ControlActionsDone()\n \u2013 Indicates that the control actions are done: {1 done, 0 not done}.\n\n\nSolution.ControlActionsDone(arg)\n \u2013 Modifies the flag to indicate that the control actions are done: {1 done, 0 not done}.\n\n\nSolution.FinishTimeStep()\n \u2013 Call cleanup, sample Monitors, and increment time at end of time step.\n\n\nSolution.Cleanup()\n \u2013 Update storage, invcontrol, etc., at end of time step.\n\n\nSolution.Frequency()\n \u2013 The frequency for the next solution.\n\n\nSolution.Frequency(arg)\n \u2013 Set the frequency for the next solution.\n\n\nSolution.Seconds()\n \u2013 The seconds from top of the hour.\n\n\nSolution.Seconds(arg)\n \u2013 Set the seconds from top of the hour.\n\n\nSolution.StepSize()\n \u2013 The step size for the next solution.\n\n\nSolution.StepSize(arg)\n \u2013 Set the step size for the next solution.\n\n\nSolution.LoadMult()\n \u2013 The default load multiplier applied to all non-fixed loads.\n\n\nSolution.LoadMult(arg)\n \u2013 Set the default load multiplier applied to all non-fixed loads.\n\n\nSolution.Convergence()\n \u2013 The solution convergence tolerance.\n\n\nSolution.Convergence(arg)\n \u2013 Set the solution convergence tolerance.\n\n\nSolution.PctGrowth()\n \u2013 The percent default annual load growth rate.\n\n\nSolution.PctGrowth(arg)\n \u2013 Set the percent default annual load growth rate.\n\n\nSolution.GenkW()\n \u2013 The generator kW for AutoAdd mode.\n\n\nSolution.GenkW(arg)\n \u2013 Set the generator kW for AutoAdd mode.\n\n\nSolution.GenPF()\n \u2013 The pf for generators in AutoAdd mode.\n\n\nSolution.GenPF(arg)\n \u2013 Set the pf for generators in AutoAdd mode.\n\n\nSolution.Capkvar()\n \u2013 The capacitor kvar for adding in AutoAdd mode.\n\n\nSolution.Capkvar(arg)\n \u2013 Set the capacitor kvar for adding in AutoAdd mode.\n\n\nSolution.GenMult()\n \u2013 The default multiplier applied to generators (like LoadMult).\n\n\nSolution.GenMult(arg)\n \u2013 Set the default multiplier applied to generators (like LoadMult).\n\n\nSolution.DblHour()\n \u2013 The hour as a double, including fractional part.\n\n\nSolution.DblHour(arg)\n \u2013 Set the hour as a double, including fractional part.\n\n\nSolution.StepSizeMin()\n \u2013 Set the step size in minutes.\n\n\nSolution.StepSizeHr()\n \u2013 Set the step size in Hours.\n\n\nSolution.ModeID()\n \u2013 The ID (text) of the present solution mode.\n\n\nSolution.LDCurve()\n \u2013 The Load-Duration Curve name for LD modes.\n\n\nSolution.LDCurve(arg)\n \u2013 Set the Load-Duration Curve name for LD modes.\n\n\nSolution.DefaultDaily()\n \u2013 \"The default daily load shape (defaults to \" * @Default_str(\").\")\n\n\nSolution.DefaultDaily(arg)\n \u2013 \"Set the default daily load shape (defaults to \" * @Default_str(\").\")\n\n\nSolution.DefaultYearly()\n \u2013 \"The default yearly load shape (defaults to \" * @Default_str(\").\")\n\n\nSolution.DefaultYearly(arg)\n \u2013 \"Set the default yearly load shape (defaults to \" * @Default_str(\").\")\n\n\nSolution.EventLog()\n \u2013 Returns an array of strings containing the Event Log.\n\n\n\n\nSwtControls\n\n\n#\nOpenDSSDirect.DSS.SwtControls\n \n \nModule\n.\n\n\n\n\nmodule SwtControls\n \u2013 Functions for interfacing with the active OpenDSS SwtControl.\n\n\nSwtControls.First()\n \u2013 Set the first SwtControl active. Returns 0 if no more.\n\n\nSwtControls.Next()\n \u2013 Set the next SwtControl active. Returns 0 if no more.\n\n\nSwtControls.Action()\n \u2013 Get the open (1) or close (2) action of the switch. No effect if switch is locked. However, reset removes any lock and then closes the switch (shelf state). 0 = none action.\n\n\nSwtControls.Action(arg)\n \u2013 Set open (1) or close (2) the switch. No effect if switch is locked. However, reset removes any lock and then closes the switch (shelf state). 0 = none action (see manual for details).\n\n\nSwtControls.IsLocked()\n \u2013 Get the lock state: {1 locked | 0 not locked}.\n\n\nSwtControls.IsLocked(arg)\n \u2013 Set the lock to prevent both manual and automatic switch operation.\n\n\nSwtControls.SwitchedTerm()\n \u2013 Get the terminal number where the switch is located on the SwitchedObj.\n\n\nSwtControls.SwitchedTerm(arg)\n \u2013 Set the terminal number where the switch is located on the SwitchedObj.\n\n\nSwtControls.Count()\n \u2013 Get the total number of SwtControls in the active circuit.\n\n\nSwtControls.Delay()\n \u2013 Get the time delay [s] between arming and opening or closing the switch. Control may reset before actually operating the switch.\n\n\nSwtControls.Delay(arg)\n \u2013 Set the time delay [s] between arming and opening or closing the switch. Control may reset before actually operating the switch.\n\n\nSwtControls.Name()\n \u2013 Get the name of the active SwtControl.\n\n\nSwtControls.Name(arg)\n \u2013 Set a SwtControl active by name.\n\n\nSwtControls.SwitchedObj()\n \u2013 Get the name of the switched object by the active SwtControl.\n\n\nSwtControls.SwitchedObj(arg)\n \u2013 Set the switched object by name.\n\n\nSwtControls.AllNames()\n \u2013 Get a vector of strings with all SwtControl names in the active circuit.\n\n\n\n\nTopology\n\n\n#\nOpenDSSDirect.DSS.Topology\n \n \nModule\n.\n\n\n\n\nmodule Topology\n \u2013 Functions for interfacing with the active OpenDSS Topology.\n\n\nTopology.NumLoops()\n \u2013 Get the number of loops.\n\n\nTopology.NumIsolatedBranches()\n \u2013 Get the number of isolated branches (PD elements and capacitors).\n\n\nTopology.NumIsolatedLoads()\n \u2013 Get the number of isolated loads.\n\n\nTopology.First()\n \u2013 Set the first branch active, returns 0 if none.\n\n\nTopology.Next()\n \u2013 Set the next branch active, returns 0 if none.\n\n\nTopology.ActiveBranch()\n \u2013 The index of the active Branch.\n\n\nTopology.ForwardBranch()\n \u2013 Move forward in the tree, return index of new active branch or 0 if no more.\n\n\nTopology.BackwardBranch()\n \u2013 Move back toward the source, return index of new active branch or 0 if no more.\n\n\nTopology.LoopedBranch()\n \u2013 Move to looped branch, return index or 0 if none.\n\n\nTopology.ParallelBranch()\n \u2013 Mode to directly parallel branch, return index or 0 if none.\n\n\nTopology.FirstLoad()\n \u2013 Set as active load the first load at the active branch, return index or 0 if none.\n\n\nTopology.NextLoad()\n \u2013 Set as active load the next load at the active branch, return index or 0 if none.\n\n\nTopology.ActiveLevel()\n \u2013 Get the topological depth of the active branch.\n\n\nTopology.BranchName()\n \u2013 Get the name of the active branch.\n\n\nTopology.BranchName(arg)\n \u2013 Set the name of the active branch.\n\n\nTopology.BusName()\n \u2013 Get the name of the active Bus.\n\n\nTopology.BusName(arg)\n \u2013 Set the Bus active by name.\n\n\nTopology.AllLoopedPairs()\n \u2013 Get a vector of all looped element names, by pairs.\n\n\nTopology.AllIsolatedBranches()\n \u2013 Get a vector of all isolated branch names.\n\n\nTopology.AllIsolatedLoads()\n \u2013 Get a vector of all isolated load names.\n\n\n\n\nTransformers\n\n\n#\nOpenDSSDirect.DSS.Transformers\n \n \nModule\n.\n\n\n\n\nmodule Transformers\n \u2013 Functions for interfacing with the active OpenDSS transformer.\n\n\nTransformers.NumWindings()\n \u2013 Get the number of windings on this transformer. Allocates memory; set or change this property first.\n\n\nTransformers.NumWindings(arg)\n \u2013 Set the number of windings on this transformer. Allocates memory; set or change this property first.\n\n\nTransformers.Wdg()\n \u2013 Get the active winding number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.).\n\n\nTransformers.Wdg(arg)\n \u2013 Set the active winding number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.).\n\n\nTransformers.NumTaps()\n \u2013 Get the active winding number of tap steps between MinTap and MaxTap.\n\n\nTransformers.NumTaps(arg)\n \u2013 Set the active winding number of tap steps between MinTap and MaxTap\n\n\nTransformers.IsDelta()\n \u2013 Get the information about if the active winding is delta (1) or wye (0) connection.\n\n\nTransformers.IsDelta(arg)\n \u2013 Set the information about if the active winding is delta (1) or wye (0) connection.\n\n\nTransformers.First()\n \u2013 Set the first Transformer active. Return 0 if no more.\n\n\nTransformers.Next()\n \u2013 Set the next Transformer active. Return 0 if no more.\n\n\nTransformers.Count()\n \u2013 Get the number of Transformers within the active circuit.\n\n\nTransformers.R()\n \u2013 Get the active winding resistance in %.\n\n\nTransformers.R(arg)\n \u2013 Set the active winding resistance in %.\n\n\nTransformers.Tap()\n \u2013 Get the active winding tap in per-unit.\n\n\nTransformers.Tap(arg)\n \u2013 Set the active winding tap in per-unit.\n\n\nTransformers.MinTap()\n \u2013 Get the active winding minimum tap in per-unit.\n\n\nTransformers.MinTap(arg)\n \u2013 Set the active winding minimum tap in per-unit.\n\n\nTransformers.MaxTap()\n \u2013 Get the active winding maximum tap in per-unit.\n\n\nTransformers.MaxTap(arg)\n \u2013 Set the active winding maximum tap in per-unit.\n\n\nTransformers.kV()\n \u2013 Get the active winding kV rating. Phase-phase for 2 or 3 phases, actual winding kV 1 phase transformer.\n\n\nTransformers.kV(arg)\n \u2013 Set the active winding kV rating. Phase-phase for 2 or 3 phases, actual winding kV 1 phase transformer.\n\n\nTransformers.kVA()\n \u2013 Get the active winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\n\n\nTransformers.kVA(arg)\n \u2013 Set the active winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\n\n\nTransformers.Xneut()\n \u2013 Get the active winding neutral reactance [ohms] for wye connections.\n\n\nTransformers.Xneut(arg)\n \u2013 Set the active winding neutral reactance [ohms] for wye connections.\n\n\nTransformers.Rneut()\n \u2013 Get the active winding neutral resistance [ohms] for wye connections. Set less than zero ungrounded wye.\n\n\nTransformers.Rneut(arg)\n \u2013 Set the active winding neutral resistance [ohms] for wye connections. Set less than zero ungrounded wye.\n\n\nTransformers.Xhl()\n \u2013 Get the percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2 winding or 3 winding Transformers.\n\n\nTransformers.Xhl(arg)\n \u2013 Set the percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2 winding or 3 winding Transformers.\n\n\nTransformers.Xht()\n \u2013 Get the percent reactance between windings 1 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.\n\n\nTransformers.Xht(arg)\n \u2013 Set the percent reactance between windings 1 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.\n\n\nTransformers.Xlt()\n \u2013 Get the percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.\n\n\nTransformers.Xlt(arg)\n \u2013 Set the percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.\n\n\nTransformers.XfmrCode()\n \u2013 Get the name of an XfrmCode that supplies electrical paraMeters for this transformer.\n\n\nTransformers.XfmrCode(arg)\n \u2013 Set the name of an XfrmCode that supplies electrical paraMeters for this transformer.\n\n\nTransformers.Name()\n \u2013 Get the active transformer name and 3, on winding_1_kVA base. Use for 3 winding transformer only.\n\n\nTransformers.Name(arg)\n \u2013 Set the active transformer name and 3, on winding_1_kVA base. Use for 3 winding transformer only.\n\n\nTransformers.AllNames()\n \u2013 Get a vector of strings with all Transformer names in the active circuit.\n\n\n\n\nVsources\n\n\n#\nOpenDSSDirect.DSS.Vsources\n \n \nModule\n.\n\n\n\n\nmodule Vsources\n \u2013 Functions for interfacing with the active OpenDSS voltage source.\n\n\nVsources.Count()\n \u2013 The number of VSource objects currently defined in the active circuit.\n\n\nVsources.First()\n \u2013 Set the first VSource to be active; returns 0 if none.\n\n\nVsources.Next()\n \u2013 Set the next VSource to be active; returns 0 if none.\n\n\nVsources.Phases()\n \u2013 Get the number of phases of the active VSource.\n\n\nVsources.Phases(arg)\n \u2013 Set the number of phases of the active VSource.\n\n\nVsources.BasekV()\n \u2013 Get the source voltage in kV.\n\n\nVsources.BasekV(arg)\n \u2013 Set the source voltage in kV.\n\n\nVsources.PU()\n \u2013 Get the source voltage in pu.\n\n\nVsources.PU(arg)\n \u2013 Set the source voltage in pu.\n\n\nVsources.AngleDeg()\n \u2013 Get the source phase angle of first phase in degrees.\n\n\nVsources.AngleDeg(arg)\n \u2013 Set the source phase angle of first phase in degrees.\n\n\nVsources.Frequency()\n \u2013 Get the source frequency in Hz.\n\n\nVsources.Frequency(arg)\n \u2013 Set the source frequency in Hz.\n\n\nVsources.Name()\n \u2013 Get the name of the active VSource.\n\n\nVsources.Name(arg)\n \u2013 Set the name of the active VSource.\n\n\nVsources.AllNames()\n \u2013 Get the names of all Vsources\n\n\n\n\nXYCurves\n\n\n#\nOpenDSSDirect.DSS.XYCurves\n \n \nModule\n.\n\n\n\n\nmodule XYCurves\n \u2013 Functions for interfacing with the active OpenDSS XYCurve.\n\n\nXYCurves.Count()\n \u2013 Get number of XYCurves in active circuit.\n\n\nXYCurves.First()\n \u2013 Set first XYCurves object active; returns 0 if none.\n\n\nXYCurves.Next()\n \u2013 Set next XYCurves object active; returns 0 if none.\n\n\nXYCurves.Npts()\n \u2013 Get the number of points in X-Y curve.\n\n\nXYCurves.Npts(arg)\n \u2013 Set the number of points in X-Y curve.\n\n\nXYCurves.X()\n \u2013 Get the interpolated value after setting Y.\n\n\nXYCurves.X(arg)\n \u2013 Set the X value.\n\n\nXYCurves.Y()\n \u2013 Get the interpolated value after setting X.\n\n\nXYCurves.Y(arg)\n \u2013 Set the Y value.\n\n\nXYCurves.XShift()\n \u2013 Get the amount to shift X value from original curve.\n\n\nXYCurves.XShift(arg)\n \u2013 Set the amount to shift X value from original curve.\n\n\nXYCurves.YShift()\n \u2013 Get the amount to shift Y value from original curve.\n\n\nXYCurves.YShift(arg)\n \u2013 Set the amount to shift Y value from original curve.\n\n\nXYCurves.XScale()\n \u2013 Get the factor to scale X values from original curve.\n\n\nXYCurves.XScale(arg)\n \u2013 Set the factor to scale X values from original curve.\n\n\nXYCurves.YScale()\n \u2013 Get the factor to scale Y values from original curve.\n\n\nXYCurves.YScale(arg)\n \u2013 Set the factor to scale Y values from original curve.\n\n\nXYCurves.Name()\n \u2013 Get the name of the active XYCurve Object.\n\n\nXYCurves.Name(arg)\n \u2013 Set the name of the active XYCurve Object.\n\n\nXYCurves.XArray()\n \u2013 Get the X values as a vector of doubles. Set Npts to max number expected if setting.\n\n\nXYCurves.YArray()\n \u2013 Get the Y values as a vector of doubles. Set Npts to max number expected if setting.", 
            "title": "API"
        }, 
        {
            "location": "/api/#main-api-module-dss", 
            "text": "The  dss  function is the main function for passing commands to OpenDSS. You can pass multi-line commands with  dss . You can also splice in Julia values with string interpolation. Here is an  example of using  dss :  using   OpenDSSDirect  filename   =   C:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss  dss (      clear      compile  $filename  )   Several functions are available for setting OpenDSS variables, getting values, and initiating commands. Each of these is in one of several modules. Here is an  example to set the  kW  of the active load element:  Loads . kW ( 50. )   Here is an example setting some loads:  using   OpenDSSDirect  filename   =   C:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss  dss (      clear      compile  $filename  )  loadnumber   =   DSS . Loads . First ()  while   loadnumber     0 \n     DSS . Loads . kW ( 50. ) \n     DSS . Loads . kvar ( 20. ) \n     loadnumber   =   DSS . Loads . Next ()  end  println ( DSS . Loads . Count ())    To use this API, you can either use  import OpenDSSDirect  and prepend all of the functions with  DSS. , or you can  import OpenDSSDirect.DSS  and use the functions directly. The following two are equivalent:  using   OpenDSSDirect  DSS . Circuit . TotalPower ()   Importing the DSS module:  using   OpenDSSDirect . DSS  Circuit . TotalPower ()   Many of the functions that return arrays convert to complex numbers where appropriate. Here is an example session:  julia   using   OpenDSSDirect . DSS  julia   filename   =   joinpath ( Pkg . dir (),   OpenDSSDirect ,   examples ,   8500-Node ,   Master.dss );  julia   dss (             clear             compile  $filename          )  julia   Solution . Solve ();  julia   Circuit . Losses ()  1.218242333223247e6   +   2.798391857088721e6 im  julia   Circuit . TotalPower ()  - 12004.740450109337   -   1471.1749507157301 im  julia   Circuit . SetActiveElement ( Capacitor.CAPBank3 )  6075  julia   CktElement . Voltages ()  6 - element   Array { Complex { Float64 }, 1 }: \n   5390.82 - 4652.32 im \n  - 6856.89 - 2274.93 im \n   1284.62 + 7285.18 im \n       0.0 + 0.0 im \n       0.0 + 0.0 im \n       0.0 + 0.0 im   To find the functions available in each module, use Julia's help for each module (initiated by hitting  ? ). See below for an example.   julia   using   OpenDSSDirect . DSS  help ?   Circuit  search :   Circuit \n\n   module   Circuit   \u2013   Functions   for   interfacing   with   the   active   OpenDSS   circuit . \n\n   Circuit . NumCktElements ()   \u2013   Number   of   CktElements   in   the   circuit \n\n   Circuit . NumBuses ()   \u2013   Total   number   of   Buses   in   the   circuit \n\n   Circuit . NumNodes ()   \u2013   Total   number   of   Nodes   in   the   circuit \n\n   Circuit . FirstPCElement ()   \u2013   Sets   the   first   enabled   Power   Conversion   ( PC )   element   in   the   circuit   to   be   active ;   if   not   successful   returns   a   0 \n\n   Circuit . NextPCElement ()   \u2013   Sets   the   next   enabled   Power   Conversion   ( PC )   element   in   the   circuit   to   be   active ;   if   not   successful   returns   a   0 \n\n   Circuit . FirstPDElement ()   \u2013   Sets   the   first   enabled   Power   Delivery   ( PD )   element   in   the   circuit   to   be   active ;   if   not   successful   returns   a   0 \n\n   Circuit . NextPDElement ()   \u2013   Sets   the   next   enabled   Power   Delivery   ( PD )   element   in   the   circuit   to   be   active ;   if   not   successful   returns   a   0 \n\n   { truncated ... }   Here is a list of modules supported by this API. Each module has several functions.   ActiveClass  Basic  Bus  CapControls  Capacitors  Circuit  CktElement  CtrlQueue  Element  Executive  Fuses  Generators  Isource  Lines  LoadShape  Loads  Meters  Monitors  PDElements  PVsystems  Parser  Progress  Properties  Reclosers  RegControls  Relays  Sensors  Settings  Solution  SwtControls  Topology  Transformers  Vsources  XYCurves  dss", 
            "title": "Main API (module DSS)"
        }, 
        {
            "location": "/api/#dss", 
            "text": "# OpenDSSDirect.DSS.dss     Function .   dss(arg::AbstractString)  Execute the OpenDSS text command  arg .", 
            "title": "dss"
        }, 
        {
            "location": "/api/#activeclass", 
            "text": "# OpenDSSDirect.DSS.ActiveClass     Module .   module ActiveClass  \u2013 Functions for interfacing with the active OpenDSS class.  ActiveClass.First()  \u2013 Sets the first element in the active class to be the active object; if object is a CktElement, ActiveCktElement also points to this element; returns 0 if none  ActiveClass.Next()  \u2013 Sets the next element in the active class to be the active object; if object is a CktElement, ActiveCktElement also points to this element; returns 0 if no more  ActiveClass.NumElements()  \u2013 Number of elements in the active class  ActiveClass.Count()  \u2013 Number of elements in the active class; same as NumElements  ActiveClass.Name()  \u2013 Name of the active element of the active class  ActiveClass.Name(arg)  \u2013 Set the name of the active element of the active class  ActiveClass.ActiveClassName()  \u2013 Name of the active class  ActiveClass.AllNames()  \u2013 All element names in the active class", 
            "title": "ActiveClass"
        }, 
        {
            "location": "/api/#basic", 
            "text": "# OpenDSSDirect.DSS.Basic     Module .   module Basic  \u2013 Includes methods for basic OpenDSS information.  Basic.NumCircuits()  \u2013 Number\u00a0of\u00a0Circuits\u00a0currently\u00a0defined  Basic.ClearAll()  \u2013 Clears\u00a0all\u00a0circuit\u00a0definitions  Basic.ShowPanel()  \u2013 Shows\u00a0non\u2010MDI\u00a0child\u00a0form\u00a0of\u00a0the\u00a0Main\u00a0DSS\u00a0Edit\u00a0Form  Basic.Start()  \u2013 Validate\u00a0the\u00a0user\u00a0and\u00a0start\u00a0OpenDSS; returns\u00a0true\u00a0if\u00a0successful  Basic.NumClasses()  \u2013 Number\u00a0of\u00a0DSS\u00a0intrinsic\u00a0classes  Basic.NumUserClasses()  \u2013 Number\u00a0of\u00a0user\u2010defined\u00a0classes  Basic.Reset()  \u2013 Resets\u00a0DSS\u00a0Initialization\u00a0for\u00a0restarts  Basic.AllowForms()  \u2013 Bool flag on the status of allowing forms  Basic.AllowForms(arg)  \u2013 Bool flag to disable forms (once disabled, can\u2019t be enabled again)  Basic.NewCircuit()  \u2013 Make\u00a0a\u00a0new\u00a0circuit  Basic.Version()  \u2013 Get\u00a0version\u00a0string\u00a0for\u00a0OpenDSS  Basic.DataPath()  \u2013 Default\u00a0file path\u00a0for\u00a0reports,\u00a0etc.  Basic.DataPath(arg)  \u2013 Set the default file path\u00a0for\u00a0reports,\u00a0etc.  Basic.DefaultEditor()  \u2013 The\u00a0path\u00a0name\u00a0for\u00a0the\u00a0default\u00a0text\u00a0editor  Basic.Classes()  \u2013 List of the names of intrinsic classes  Basic.UserClasses()  \u2013 List of the names of user-defined classes", 
            "title": "Basic"
        }, 
        {
            "location": "/api/#bus", 
            "text": "# OpenDSSDirect.DSS.Bus     Module .   module Bus  \u2013 Functions for interfacing with the active OpenDSS bus.  Bus.NumNodes()  \u2013 Number of nodes  Bus.ZscRefresh()  \u2013 Refresh Zsc and Ysc values; execute after a major change in the circuit  Bus.Coorddefined()  \u2013 Returns true if the X-Y coordinates are defined for the active bus  Bus.GetUniqueNodeNumber()  \u2013 Returns\u00a0a\u00a0unique\u00a0node\u00a0number\u00a0at\u00a0the\u00a0active\u00a0bus\u00a0to\u00a0avoid node\u00a0collisions\u00a0and\u00a0adds\u00a0it\u00a0to\u00a0the\u00a0node\u00a0list\u00a0for\u00a0the\u00a0bus  Bus.N_Customers()  \u2013 Returns the total number of customers downline from the active bus after reliability calcs  Bus.SectionID()  \u2013 Integer ID of the feeder section in which this bus is located  Bus.kVBase()  \u2013 Base voltage  Bus.X()  \u2013 X coordinate of the bus  Bus.X(arg)  \u2013 Set the X coordinate of the bus  Bus.Y()  \u2013 Y coordinate of the bus  Bus.Y(arg)  \u2013 Set the Y coordinate of the bus  Bus.Distance()  \u2013 Distance in km that this bus isfrom the parent EnergyMeter  Bus.Lambda()  \u2013 Total annual failure rate for active bus after reliability calcs  Bus.N_interrupts()  \u2013 Number\u00a0of\u00a0interruptions\u00a0this\u00a0bus\u00a0per\u00a0year  Bus.Int_Duration()  \u2013 Average interruption duration, hours  Bus.Cust_Interrupts()  \u2013 Annual number of customer-interruptions from this bus  Bus.Cust_Duration()  \u2013 Accumulated customer outage durations, hours  Bus.TotalMiles()  \u2013 Total length of line downline from this bus, miles  Bus.Name()  \u2013 Active bus name; set the active bus by name with  circuit.SetActiveBus(name)  Bus.Voltages()  \u2013 Bus voltages, complex  Bus.SeqVoltages()  \u2013 Sequence voltages in order of 0, 1, then 2  Bus.Nodes()  \u2013 Vector of node numbers defined at the bus in the same order as the voltages  Bus.Voc()  \u2013 Open-circuit voltage vector, complex  Bus.Isc()  \u2013 Short-circuit current vector, complex  Bus.PuVoltage()  \u2013 Per-unit voltages at the bus, complex  Bus.ZscMatrix()  \u2013 Short-circuit impedance matrix, complex  Bus.Zsc1()  \u2013 Positive-sequence short-circuit impedance looking into the bus, complex  Bus.Zsc0()  \u2013 Zero-sequence short-circuit impedance looking into the bus, complex  Bus.YscMatrix()  \u2013 Short-circuit admittance matrix, complex  Bus.CplxSeqVoltages()  \u2013 All complex sequence voltages  Bus.VLL()  \u2013 Complex vector of line-to-line voltages for 2- and 3-phase buses; returns -1. for a 1-phase bus; for more than 3 phases, only returns 3 phases  Bus.puVLL()  \u2013 Complex vector of per-unit line-to-line voltages for 2- and 3-phase buses; returns -1. for a 1-phase bus; for more than 3 phases, only returns 3 phases  Bus.VMagAngle()  \u2013 Bus voltage magnitudes with angles  Bus.puVmagAngle()  \u2013 Bus voltage magnitudes (per unit) with angles", 
            "title": "Bus"
        }, 
        {
            "location": "/api/#capacitors", 
            "text": "# OpenDSSDirect.DSS.Capacitors     Module .   module Capacitors  \u2013 Functions for interfacing with the active OpenDSS capacitor.  Capacitors.NumSteps()  \u2013 Number\u00a0of\u00a0steps  Capacitors.NumSteps(arg)  \u2013 Set the number\u00a0of\u00a0steps  Capacitors.IsDelta()  \u2013 Is the connection a delta  Capacitors.IsDelta(arg)  \u2013 Set connection type; use  arg==true  for delta and  arg==false  for wye  Capacitors.First()  \u2013 Sets the first Capacitor active; returns 0 if none  Capacitors.Next()  \u2013 Sets the next Capacitor active; returns 0 if no more  Capacitors.Count()  \u2013 Number of capacitor objects in the active circuit  Capacitors.AddStep()  \u2013 Adds one step of the capacitor if available; if successful, returns 1  Capacitors.SubtractStep()  \u2013 Subtracts one step of the capacitor; if no more steps, returns 0  Capacitors.AvailableSteps()  \u2013 Number of steps available in the cap bank to be switched ON  Capacitors.Open()  \u2013 Open all steps, all phases of the capacitor  Capacitors.Close()  \u2013 Close all steps of all phases of the capacitor  Capacitors.kV()  \u2013 Bank\u00a0kV\u00a0rating; use\u00a0LL\u00a0for\u00a02\u00a0or\u00a03\u00a0phases,\u00a0or\u00a0actual\u00a0can\u00a0rating\u00a0for\u00a01\u00a0phase  Capacitors.kV(arg)  \u2013 Set the bank\u00a0kV\u00a0rating; use\u00a0LL\u00a0for\u00a02\u00a0or\u00a03\u00a0phases,\u00a0or\u00a0actual\u00a0can\u00a0rating\u00a0for\u00a01\u00a0phase  Capacitors.kvar()  \u2013 Total\u00a0bank\u00a0kvar,\u00a0distributed\u00a0equally\u00a0among\u00a0phases\u00a0and\u00a0steps  Capacitors.kvar(arg)  \u2013 Set the total\u00a0bank\u00a0kvar,\u00a0distributed\u00a0equally\u00a0among\u00a0phases\u00a0and\u00a0steps  Capacitors.Name()  \u2013 The name of the active capacitor  Capacitors.Name(arg)  \u2013 Sets the active capacitor by name  Capacitors.AllNames()  \u2013 All capacitor names in the circuit  Capacitors.States()  \u2013 A vector of \u00a0integers\u00a0[0..numsteps\u20101]\u00a0indicating\u00a0state\u00a0of\u00a0each\u00a0step; if value\u00a0is\u00a0\u20101\u00a0an\u00a0error\u00a0has\u00a0occurred.", 
            "title": "Capacitors"
        }, 
        {
            "location": "/api/#capcontrols", 
            "text": "# OpenDSSDirect.DSS.CapControls     Module .   module CapControls  \u2013 Functions for interfacing with the active OpenDSS CapControl.  CapControls.First()  \u2013 Sets the first CapControl active; returns 0 if none  CapControls.Next()  \u2013 Sets the next CapControl active; returns 0 if no more  CapControls.Mode()  \u2013 Type of automatic controller; for meaning, see CapControlModes  CapControls.Mode(arg)  \u2013 Set the type of automatic controller; for choices, see CapControlModes  CapControls.MonitoredTerm()  \u2013 Terminal\u00a0number\u00a0on\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to  CapControls.MonitoredTerm(arg)  \u2013 Set the terminal\u00a0number\u00a0on\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to  CapControls.UseVoltOverride()  \u2013 Bool flag that enables\u00a0Vmin\u00a0and\u00a0Vmax\u00a0to\u00a0override\u00a0the\u00a0control\u00a0mode  CapControls.UseVoltOverride(arg)  \u2013 Set the Bool flag that enables\u00a0Vmin\u00a0and\u00a0Vmax\u00a0to\u00a0override\u00a0the\u00a0control\u00a0mode  CapControls.Count()  \u2013 Number of CapControls in the active circuit  CapControls.CTRatio()  \u2013 Transducer\u00a0ratio\u00a0from\u00a0primary\u00a0current\u00a0to\u00a0control\u00a0current  CapControls.CTRatio(arg)  \u2013 Set the transducer\u00a0ratio\u00a0from\u00a0primary\u00a0current\u00a0to\u00a0control\u00a0current  CapControls.PTRatio()  \u2013 Transducer\u00a0ratio\u00a0from\u00a0primary\u00a0voltage\u00a0to\u00a0control\u00a0voltage  CapControls.PTRatio(arg)  \u2013 Set the transducer\u00a0ratio\u00a0from\u00a0primary\u00a0voltage\u00a0to\u00a0control\u00a0voltage  CapControls.ONSetting()  \u2013 Threshold\u00a0to\u00a0arm\u00a0or\u00a0switch\u00a0on\u00a0a\u00a0step; see\u00a0Mode\u00a0for\u00a0units  CapControls.ONSetting(arg)  \u2013 Set the threshold\u00a0to\u00a0arm\u00a0or\u00a0switch\u00a0on\u00a0a\u00a0step; see\u00a0Mode\u00a0for\u00a0units  CapControls.OFFSetting()  \u2013 Threshold\u00a0to\u00a0switch\u00a0off\u00a0a\u00a0step; see\u00a0the particular CapControlModes option\u00a0for\u00a0units  CapControls.OFFSetting(arg)  \u2013 Set the threshold\u00a0to\u00a0switch\u00a0off\u00a0a\u00a0step; see\u00a0the particular CapControlModes option\u00a0for\u00a0units  CapControls.Vmax()  \u2013 With\u00a0VoltOverride,\u00a0switch\u00a0off\u00a0whenever\u00a0PT\u00a0voltage\u00a0exceeds\u00a0this\u00a0level  CapControls.Vmax(arg)  \u2013 Set Vmax; with\u00a0VoltOverride,\u00a0switch\u00a0off\u00a0whenever\u00a0PT\u00a0voltage\u00a0exceeds\u00a0this\u00a0level  CapControls.Vmin()  \u2013 With\u00a0VoltOverride,\u00a0switch\u00a0on\u00a0whenever\u00a0PT\u00a0voltage\u00a0drops below\u00a0this\u00a0level  CapControls.Vmin(arg)  \u2013 Set Vmin; with\u00a0VoltOverride,\u00a0switch\u00a0on\u00a0whenever\u00a0PT\u00a0voltage\u00a0drops below\u00a0this\u00a0level  CapControls.Delay()  \u2013 Time\u00a0delay\u00a0[s]\u00a0to\u00a0switch\u00a0on\u00a0after\u00a0arming; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching  CapControls.Delay(arg)  \u2013 Set the time\u00a0delay\u00a0[s]\u00a0to\u00a0switch\u00a0on\u00a0after\u00a0arming; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching  CapControls.DelayOff()  \u2013 Time\u00a0delay\u00a0[s]\u00a0before\u00a0switching\u00a0off\u00a0a\u00a0step; control\u00a0may\u00a0reset\u00a0before\u00a0actuallyswitching  CapControls.DelayOff(arg)  \u2013 Set the time\u00a0delay\u00a0[s]\u00a0before\u00a0switching\u00a0off\u00a0a\u00a0step; control\u00a0may\u00a0reset\u00a0before\u00a0actually switching  CapControls.Name()  \u2013 The name of the active CapControl  CapControls.Name(arg)  \u2013 Set the active CapControl by name  CapControls.Capacitor()  \u2013 Name of the Capacitor that is controlled  CapControls.Capacitor(arg)  \u2013 Set the Capacitor (by name) that is controlled  CapControls.MonitoredObj()  \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0element\u00a0that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to  CapControls.MonitoredObj(arg)  \u2013 Set the\u00a0element\u00a0(by full name) that\u00a0PT\u00a0and\u00a0CT\u00a0are\u00a0connected\u00a0to  CapControls.AllNames()  \u2013 Names of all CapControls in the circuit", 
            "title": "CapControls"
        }, 
        {
            "location": "/api/#circuit", 
            "text": "# OpenDSSDirect.DSS.Circuit     Module .   module Circuit  \u2013 Functions for interfacing with the active OpenDSS circuit.  Circuit.NumCktElements()  \u2013 Number of CktElements in the circuit  Circuit.NumBuses()  \u2013 Total number of Buses in the circuit  Circuit.NumNodes()  \u2013 Total number of Nodes in the circuit  Circuit.FirstPCElement()  \u2013 Sets the first enabled Power Conversion (PC) element in the circuit to be active; if not successful returns a 0  Circuit.NextPCElement()  \u2013 Sets the next enabled Power Conversion (PC) element in the circuit to be active; if not successful returns a 0  Circuit.FirstPDElement()  \u2013 Sets the first enabled Power Delivery (PD) element in the circuit to be active; if not successful returns a 0  Circuit.NextPDElement()  \u2013 Sets the next enabled Power Delivery (PD) element in the circuit to be active; if not successful returns a 0  Circuit.Sample()  \u2013 Force\u00a0all\u00a0Meters\u00a0and\u00a0Monitors\u00a0to\u00a0take\u00a0a\u00a0sample  Circuit.SaveSample()  \u2013 Force\u00a0all\u00a0Meters\u00a0and\u00a0Monitors\u00a0to\u00a0save\u00a0their\u00a0current\u00a0buffers  Circuit.SetActiveBusi(arg)  \u2013 Sets the active bus by integer index. The index is 0 based. That is, the first bus has an index of 0. Returns -1 if an error occurs.  Circuit.FirstElement()  \u2013 Sets\u00a0First\u00a0element\u00a0of\u00a0active\u00a0class\u00a0to\u00a0be\u00a0the\u00a0Active\u00a0element\u00a0in\u00a0the\u00a0active circuit.\u00a0Returns\u00a00\u00a0if\u00a0none.  Circuit.NextElement()  \u2013 Sets\u00a0the\u00a0next\u00a0element\u00a0of\u00a0the\u00a0active\u00a0class\u00a0to\u00a0be\u00a0the\u00a0active\u00a0element\u00a0in\u00a0the active\u00a0circuit.\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more\u00a0elements.  Circuit.UpdateStorage()  \u2013 Forces\u00a0update\u00a0to\u00a0all\u00a0storage\u00a0classes.\u00a0Typically\u00a0done\u00a0after\u00a0a\u00a0solution. Done\u00a0automatically\u00a0in\u00a0intrinsic\u00a0solution\u00a0modes.  Circuit.ParentPDElement()  \u2013 Sets\u00a0Parent\u00a0PD\u00a0element,\u00a0if\u00a0any,\u00a0to\u00a0be\u00a0the\u00a0active\u00a0circuit\u00a0element\u00a0and returns\u00a0index 0;\u00a0Returns\u00a00\u00a0if\u00a0it\u00a0fails\u00a0or\u00a0not\u00a0applicable.  Circuit.EndOfTimeStepUpdate()  \u2013 Calls\u00a0EndOfTimeStepCleanup\u00a0in\u00a0SolutionAlgs  Circuit.Capacity(arg1, arg2)  \u2013 Executes the DSS capacity function. Start is the per unit load multiplier for the current year at which to start the search. Increment is the per unit value by which the load increments for each step of the analysis. The program sets the load at the Start value the PRESENT YEAR (including growth) and increments the load until something in thecircuit reports an overload or undervoltage violation. The function returns the total load at which the violation occurs or the peak load for the present year if no violations.  Circuit.Name()  \u2013 Name of the active circuit  Circuit.Disable(arg)  \u2013 Disable a circuit element by name (full name).  Circuit.Enable(arg)  \u2013 Enable a circuit element by name (full name).  Circuit.SetActiveElement(arg)  \u2013 Activate an element of the active circuit by name. Returns a string with the index of the active element.  Circuit.SetActiveBus(arg)  \u2013 Sets the active bus by name. Returns a 0 based index of the bus to use for future direct indexing of bus values returned in arrays. Returns -1 if an error occurs.  Circuit.SetActiveClass(arg)  \u2013 Sets\u00a0the\u00a0active\u00a0class\u00a0by\u00a0name.\u00a0\u00a0Use\u00a0FirstElement,\u00a0NextElement\u00a0to iterate\u00a0through\u00a0the\u00a0class.\u00a0Returns\u00a0\u20101\u00a0if\u00a0fails.  Circuit.Losses()  \u2013 Watt and var losses in the entire circuit, complex  Circuit.LineLosses()  \u2013 Watt and var losses in all the Line elements in the circuit, complex  Circuit.SubstationLosses()  \u2013 Watt and var losses in all the Transformer elements in the circuit that are designated as substations  Circuit.TotalPower()  \u2013 Returns the total power in kW and kvar supplied to the circuit by all Vsource and Isource objects. Does not include Generator objects. Complex.  Circuit.AllBusVolts()  \u2013 Returns the voltage (complex) for every node in the circuit as a complex vector. The order of the array is the same as AllNodeNames property. The array is constructed bus-by-bus and then by node at each bus. Thus, all nodes from each bus are grouped together.  Circuit.AllBusVMag()  \u2013 Similar to AllBusVolts except magnitude only (in actual volts). Returns the voltage (magnitude) for every node in the circuit as a complex vector.  Circuit.AllElementNames()  \u2013 The names of all elements  Circuit.AllBusNames()  \u2013 The names of all buses in the system. See  :AllNodeNames .  Circuit.AllElementLosses()  \u2013 Returns the watt and var losses in each element of the system as a complex vector. Order is the same as AllElementNames.  Circuit.AllBusMagPu()  \u2013 Similar to AllBusVmag except that the magnitudes are reported in per unit for all buses with kVBase defined.  Circuit.AllNodeNames()  \u2013 Returns the names of all nodes (busname.nodenumber) in the same order as AllBusVolts, AllBusVmag, and AllBusVMagPu  Circuit.SystemY()  \u2013 Return the System Y matrix as a complex (dense) matrix  Circuit.AllBusDistances()  \u2013 Returns all distances from a bus to its parent EnergyMeter element, which is generally in the substation, as a variant array of doubles. Order corresponds to that of all bus properties.  Circuit.AllNodeDistances()  \u2013 Returns the distance from all nodes to the parent energy meter that match the designated phase number. Returns a vector of doubles. Matches the order of AllNodeNamesByPhase, AllNodeVmagByPhase, AllNodeVmagPUByPhase.  Circuit.YNodeVArray()  \u2013 Complex\u00a0array\u00a0of\u00a0actual\u00a0node\u00a0voltages\u00a0in\u00a0same\u00a0order\u00a0as\u00a0SystemY matrix.  Circuit.YNodeOrder()  \u2013 The\u00a0names\u00a0of\u00a0the\u00a0nodes\u00a0in\u00a0the\u00a0same order\u00a0as\u00a0the\u00a0Y\u00a0matrix  Circuit.YCurrents()  \u2013 Vector\u00a0of\u00a0doubles\u00a0containing\u00a0complex\u00a0injection\u00a0currents\u00a0for\u00a0the present\u00a0solution.", 
            "title": "Circuit"
        }, 
        {
            "location": "/api/#cktelement", 
            "text": "# OpenDSSDirect.DSS.CktElement     Module .   module CktElement  \u2013 Functions for interfacing with the active OpenDSS CktElement.  CktElement.NumTerminals()  \u2013 Number\u00a0of\u00a0Terminals\u00a0on this\u00a0Circuit\u00a0Element  CktElement.NumConductors()  \u2013 Number\u00a0of\u00a0Conductors\u00a0per\u00a0Terminal  CktElement.NumPhases()  \u2013 Number of phases  CktElement.Open()  \u2013 Open\u00a0the\u00a0specified\u00a0terminal\u00a0and\u00a0phase,\u00a0if\u00a0non\u2010zero.\u00a0\u00a0Else\u00a0all\u00a0conductors\u00a0at terminal.  CktElement.Close()  \u2013 Close\u00a0the\u00a0specified\u00a0terminal\u00a0and\u00a0phase,\u00a0if\u00a0non\u2010zero.\u00a0\u00a0Else\u00a0all\u00a0conductors\u00a0at terminal.  CktElement.IsOpen()  \u2013 Bool\u00a0indicating\u00a0if\u00a0the\u00a0specified\u00a0terminal\u00a0and,\u00a0optionally,\u00a0phase\u00a0is\u00a0open.  CktElement.NumProperties()  \u2013 Number\u00a0of\u00a0Properties\u00a0this\u00a0Circuit\u00a0Element.  CktElement.HasSwitchControl()  \u2013 Bool indicating whether this\u00a0element\u00a0has\u00a0a\u00a0SwtControl\u00a0attached.  CktElement.HasVoltControl()  \u2013 This\u00a0element\u00a0has\u00a0a\u00a0CapControl\u00a0or\u00a0RegControl\u00a0attached.  CktElement.NumControls()  \u2013 Number\u00a0of\u00a0controls\u00a0connected\u00a0to\u00a0this\u00a0device.\u00a0Use\u00a0to\u00a0determine\u00a0valid range\u00a0for\u00a0index\u00a0into\u00a0Controller\u00a0array.  CktElement.OCPDevIndex()  \u2013 Index\u00a0into\u00a0Controller\u00a0list\u00a0of\u00a0OCP\u00a0Device\u00a0controlling\u00a0this\u00a0CktElement  CktElement.OCPDevType()  \u2013 0=None;\u00a01=Fuse;\u00a02=Recloser;\u00a03=Relay;\u00a0\u00a0Type\u00a0of\u00a0OCP\u00a0controller\u00a0device  CktElement.Enabled()  \u2013 Element is enabled  CktElement.Enabled(arg)  \u2013 Enable the active circuit element  CktElement.NormalAmps()  \u2013 Normal\u00a0ampere\u00a0rating\u00a0for\u00a0PD\u00a0Elements  CktElement.NormalAmps(arg)  \u2013 Set the normal\u00a0ampere\u00a0rating\u00a0for\u00a0PD\u00a0Elements  CktElement.EmergAmps()  \u2013 Emergency\u00a0Ampere\u00a0Rating\u00a0for\u00a0PD\u00a0elements  CktElement.EmergAmps(arg)  \u2013 Set the emergency\u00a0Ampere\u00a0Rating\u00a0for\u00a0PD\u00a0elements  CktElement.Variablei()  \u2013 For\u00a0PCElement,\u00a0get\u00a0the\u00a0value\u00a0of\u00a0a\u00a0variable\u00a0by\u00a0integer\u00a0index.  CktElement.Name()  \u2013 Full\u00a0Name\u00a0of\u00a0Active\u00a0Circuit\u00a0Element  CktElement.DisplayName()  \u2013 Display\u00a0name\u00a0of\u00a0the\u00a0object\u00a0(not\u00a0necessarily\u00a0unique)  CktElement.DisplayName(arg)  \u2013 Set the display\u00a0name\u00a0of\u00a0the\u00a0object\u00a0(not\u00a0necessarily\u00a0unique)  CktElement.GUID()  \u2013 Globally\u00a0unique\u00a0identifier\u00a0for\u00a0this\u00a0object  CktElement.EnergyMeter()  \u2013 Name\u00a0of\u00a0the\u00a0Energy\u00a0Meter\u00a0this\u00a0element\u00a0is\u00a0assigned\u00a0to  CktElement.Controller()  \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0i\u2010th\u00a0controller\u00a0attached\u00a0to\u00a0this\u00a0element.\u00a0Ex:\u00a0str\u00a0=\u00a0Controller  CktElement.BusNames()  \u2013 Get\u00a0\u00a0Bus\u00a0definitions\u00a0to\u00a0which\u00a0each\u00a0terminal\u00a0is connected.\u00a00\u2010based\u00a0array.  CktElement.Voltages()  \u2013 Complex\u00a0array\u00a0of\u00a0voltages\u00a0at\u00a0terminals  CktElement.Currents()  \u2013 Complex\u00a0array\u00a0of\u00a0currents\u00a0into\u00a0each\u00a0conductor\u00a0of\u00a0each\u00a0terminal  CktElement.Powers()  \u2013 Complex\u00a0array\u00a0of\u00a0powers\u00a0into\u00a0each\u00a0conductor\u00a0of\u00a0each\u00a0terminal  CktElement.Losses()  \u2013 Total\u00a0losses\u00a0in\u00a0the\u00a0element:\u00a0two\u2010element\u00a0complex\u00a0array  CktElement.PhaseLosses()  \u2013 Complex\u00a0array\u00a0of\u00a0losses\u00a0by\u00a0phase  CktElement.SeqVoltages()  \u2013 Double\u00a0array\u00a0of\u00a0symmetrical\u00a0component\u00a0voltages\u00a0at\u00a0each\u00a03\u2010phase terminal  CktElement.SeqCurrents()  \u2013 Double\u00a0array\u00a0of\u00a0symmetrical\u00a0component\u00a0currents\u00a0into\u00a0each\u00a03\u2010phase terminal  CktElement.SeqPowers()  \u2013 Double\u00a0array\u00a0of\u00a0sequence\u00a0powers\u00a0into\u00a0each\u00a03\u2010phase\u00a0teminal  CktElement.AllPropertyNames()  \u2013 All\u00a0property\u00a0names\u00a0of\u00a0the\u00a0active\u00a0device.  CktElement.Residuals()  \u2013 Residual\u00a0currents\u00a0for\u00a0each\u00a0terminal:\u00a0(mag,\u00a0angle)  CktElement.YPrim()  \u2013 YPrim\u00a0matrix,\u00a0column\u00a0order,\u00a0complex\u00a0numbers  CktElement.CplxSeqVoltages()  \u2013 Complex\u00a0double\u00a0array\u00a0of\u00a0Sequence\u00a0Voltage\u00a0for\u00a0all\u00a0terminals\u00a0of\u00a0active circuit\u00a0element.  CktElement.CplxSeqCurrents()  \u2013 Complex\u00a0double\u00a0array\u00a0of\u00a0Sequence\u00a0Currents\u00a0for\u00a0all\u00a0conductors\u00a0of\u00a0all terminals\u00a0of\u00a0active\u00a0circuit\u00a0element.  CktElement.AllVariableNames()  \u2013 Variant\u00a0array\u00a0of\u00a0strings\u00a0listing\u00a0all\u00a0the\u00a0published\u00a0variable\u00a0names,\u00a0if\u00a0a PCElement.\u00a0Otherwise,\u00a0null\u00a0string.  CktElement.AllVariableValues()  \u2013 Values\u00a0of\u00a0state\u00a0variables\u00a0of\u00a0active\u00a0element if\u00a0PC\u00a0element.  CktElement.NodeOrder()  \u2013 Node\u00a0numbers\u00a0(representing phases,\u00a0for\u00a0example)  CktElement.CurrentsMagAng()  \u2013 Currents\u00a0in\u00a0magnitude,\u00a0angle\u00a0format\u00a0as\u00a0a\u00a0variant\u00a0array\u00a0of\u00a0doubles.  CktElement.VoltagesMagAng()  \u2013 Voltages\u00a0at\u00a0each\u00a0conductor\u00a0in\u00a0magnitude,\u00a0angle\u00a0form\u00a0as\u00a0variant array\u00a0of\u00a0doubles.", 
            "title": "CktElement"
        }, 
        {
            "location": "/api/#ctrlqueue", 
            "text": "# OpenDSSDirect.DSS.CtrlQueue     Module .   module CtrlQueue  \u2013 Functions for interfacing with the OpenDSS CtrlQueue.  CtrlQueue.ClearQueue()  \u2013 Clear the\u00a0control\u00a0queue.  CtrlQueue.Delete()  \u2013 Delete\u00a0a\u00a0control\u00a0action\u00a0from\u00a0the\u00a0DSS\u00a0control\u00a0queue\u00a0by\u00a0referencing\u00a0the\u00a0handle of\u00a0the\u00a0action  CtrlQueue.NumActions()  \u2013 Number\u00a0of\u00a0Actions\u00a0on\u00a0the\u00a0current\u00a0actionlist\u00a0(that\u00a0have\u00a0been\u00a0popped\u00a0off the\u00a0control\u00a0queue\u00a0by\u00a0CheckControlActions  CtrlQueue.Action(arg)  \u2013 Set\u00a0the\u00a0active\u00a0action\u00a0by\u00a0index  CtrlQueue.ActionCode()  \u2013 Code\u00a0for\u00a0the\u00a0active\u00a0action.\u00a0Long\u00a0integer\u00a0code\u00a0to\u00a0tell\u00a0the\u00a0control\u00a0device what\u00a0to\u00a0do.  CtrlQueue.DeviceHandle()  \u2013 Handle\u00a0(User\u00a0defined)  CtrlQueue.Push()  \u2013 Push\u00a0a\u00a0control\u00a0action\u00a0onto\u00a0the\u00a0DSS\u00a0control\u00a0queue\u00a0by\u00a0time,\u00a0action\u00a0code,\u00a0and device\u00a0handle\u00a0(user\u00a0defined).  CtrlQueue.Show()  \u2013 Show\u00a0the entire\u00a0control\u00a0queue\u00a0in\u00a0CSV\u00a0format  CtrlQueue.ClearActions()  \u2013 Clear the Action list.  CtrlQueue.PopAction()  \u2013 Pops\u00a0next\u00a0action\u00a0off\u00a0the\u00a0action\u00a0list\u00a0and\u00a0makes\u00a0it\u00a0the\u00a0active\u00a0action.\u00a0Returns zero\u00a0if\u00a0none.", 
            "title": "CtrlQueue"
        }, 
        {
            "location": "/api/#element", 
            "text": "# OpenDSSDirect.DSS.Element     Module .   module Element  \u2013 Functions for interfacing with the OpenDSS Elements.  Element.NumProperties()  \u2013 Number\u00a0of\u00a0Properties\u00a0for\u00a0the\u00a0active\u00a0DSS\u00a0object.  Element.Name()  \u2013 Full\u00a0Name\u00a0of\u00a0Active\u00a0DSS\u00a0Object\u00a0(general\u00a0element\u00a0or\u00a0circuit\u00a0element)  Element.AllPropertyNames()  \u2013 The\u00a0names\u00a0of\u00a0all\u00a0properties\u00a0for the\u00a0active\u00a0DSS\u00a0object.", 
            "title": "Element"
        }, 
        {
            "location": "/api/#executive", 
            "text": "# OpenDSSDirect.DSS.Executive     Module .   module Executive  \u2013 Functions for accessing DSSExecutive.  Executive.NumCommands()  \u2013 Number\u00a0of\u00a0DSS\u00a0Executive\u00a0Commands  Executive.NumOptions()  \u2013 Number\u00a0of\u00a0DSS\u00a0Executive\u00a0Options  Executive.Command(arg)  \u2013 Get\u00a0i\u2010th\u00a0command (with i as a string)  Executive.Option(arg)  \u2013 Get\u00a0i\u2010th\u00a0option (with i as a string)  Executive.CommandHelp(arg)  \u2013 Get\u00a0help\u00a0string\u00a0for\u00a0i\u2010th\u00a0command (with i as a string)  Executive.OptionHelp(arg)  \u2013 Get\u00a0help\u00a0string\u00a0for\u00a0i\u2010th\u00a0option (with i as a string)  Executive.OptionValue(arg)  \u2013 Get\u00a0present\u00a0value\u00a0of\u00a0i\u2010th\u00a0option (with i as a string)", 
            "title": "Executive"
        }, 
        {
            "location": "/api/#fuses", 
            "text": "# OpenDSSDirect.DSS.Fuses     Module .   module Fuses  \u2013 Functions for interfacing with the active OpenDSS Fuse.  Fuses.Count()  \u2013 Number\u00a0of\u00a0Fuse\u00a0elements\u00a0in\u00a0the\u00a0circuit  Fuses.First()  \u2013 Set\u00a0the\u00a0first\u00a0Fuse\u00a0to\u00a0be\u00a0the\u00a0active\u00a0fuse.\u00a0Returns\u00a00\u00a0if\u00a0none.  Fuses.Next()  \u2013 Advance\u00a0the\u00a0active\u00a0Fuse\u00a0element\u00a0pointer\u00a0to\u00a0the\u00a0next\u00a0fuse.\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more fuses.  Fuses.MonitoredTerm()  \u2013 Terminal\u00a0number\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.  Fuses.MonitoredTerm(arg)  \u2013 Set the terminal\u00a0number\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.  Fuses.Open()  \u2013 Manual\u00a0opening\u00a0of\u00a0fuse  Fuses.Close()  \u2013 Close\u00a0the\u00a0fuse\u00a0back\u00a0in\u00a0and\u00a0reset.  Fuses.IsBlown()  \u2013 Current\u00a0state\u00a0of\u00a0the\u00a0fuses.\u00a0TRUE\u00a0if\u00a0any\u00a0fuse\u00a0on\u00a0any\u00a0phase\u00a0is\u00a0blown.\u00a0Else FALSE.  Fuses.Idx()  \u2013 Get/set\u00a0active\u00a0fuse\u00a0by\u00a0index\u00a0into\u00a0the\u00a0list\u00a0of\u00a0fuses.\u00a01\u00a0based:\u00a01..count  Fuses.Idx(arg)  \u2013 Set\u00a0Fuse\u00a0active\u00a0by\u00a0index\u00a0into\u00a0the\u00a0list\u00a0of\u00a0fuses.\u00a01..count  Fuses.NumPhases()  \u2013 Number\u00a0of\u00a0phases,\u00a0this\u00a0fuse.  Fuses.RatedCurrent()  \u2013 Multiplier\u00a0or\u00a0actual\u00a0amps\u00a0for\u00a0the\u00a0TCCcurve\u00a0object.\u00a0Defaults\u00a0to\u00a01.0.\u00a0Multipliy\u00a0current\u00a0values\u00a0of\u00a0TCC\u00a0curve\u00a0by\u00a0this\u00a0to\u00a0get\u00a0actual\u00a0amps.  Fuses.RatedCurrent(arg)  \u2013 Set the multiplier\u00a0or\u00a0actual\u00a0amps\u00a0for\u00a0the\u00a0TCCcurve\u00a0object.\u00a0Defaults\u00a0to\u00a01.0.\u00a0Multipliy\u00a0current\u00a0values\u00a0of\u00a0TCC\u00a0curve\u00a0by\u00a0this\u00a0to\u00a0get\u00a0actual\u00a0amps.  Fuses.Name()  \u2013 Get\u00a0the\u00a0name\u00a0of\u00a0the\u00a0active\u00a0Fuse\u00a0element  Fuses.Name(arg)  \u2013 Set\u00a0the\u00a0name\u00a0of\u00a0the\u00a0active\u00a0Fuse\u00a0element  Fuses.MonitoredObj()  \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.  Fuses.MonitoredObj(arg)  \u2013 Set the full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0to\u00a0which\u00a0the\u00a0fuse\u00a0is\u00a0connected.  Fuses.SwitchedObj()  \u2013 Full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0switch\u00a0that\u00a0the\u00a0fuse\u00a0controls.\u00a0Defaults\u00a0to the\u00a0MonitoredObj.  Fuses.SwitchedObj(arg)  \u2013 Set the full\u00a0name\u00a0of\u00a0the\u00a0circuit\u00a0element\u00a0switch\u00a0that\u00a0the\u00a0fuse\u00a0controls.\u00a0Defaults\u00a0to the\u00a0MonitoredObj.  Fuses.TCCCurve()  \u2013 Name\u00a0of\u00a0the\u00a0TCCcurve\u00a0object\u00a0that\u00a0determines\u00a0fuse\u00a0blowing.  Fuses.TCCCurve(arg)  \u2013 Set the name\u00a0of\u00a0the\u00a0TCCcurve\u00a0object\u00a0that\u00a0determines\u00a0fuse\u00a0blowing.  Fuses.AllNames()  \u2013 \u00a0Names\u00a0of\u00a0all\u00a0Fuses\u00a0in\u00a0the\u00a0circuit", 
            "title": "Fuses"
        }, 
        {
            "location": "/api/#generators", 
            "text": "# OpenDSSDirect.DSS.Generators     Module .   module Generators  \u2013 Functions for interfacing with the active OpenDSS Generator.  Generators.First()  \u2013 Sets\u00a0first\u00a0Generator\u00a0to\u00a0be\u00a0active.\u00a0\u00a0Returns\u00a00\u00a0if\u00a0none.  Generators.Next()  \u2013 Sets\u00a0next\u00a0Generator\u00a0to\u00a0be\u00a0active.\u00a0\u00a0Returns\u00a00\u00a0if\u00a0no\u00a0more.  Generators.ForcedON()  \u2013 Indicates\u00a0whether\u00a0the\u00a0generator\u00a0is\u00a0forced\u00a0ON\u00a0regardles\u00a0of\u00a0other\u00a0dispatch criteria.  Generators.ForcedON(arg)  \u2013 Sets indication\u00a0whether\u00a0the\u00a0generator\u00a0is\u00a0forced\u00a0ON\u00a0regardles\u00a0of\u00a0other\u00a0dispatch criteria.  Generators.Phases()  \u2013 Number of phases  Generators.Phases(arg)  \u2013 Set the number\u00a0of\u00a0phases  Generators.Count()  \u2013 Number\u00a0of\u00a0Generator\u00a0Objects\u00a0in\u00a0Active\u00a0Circuit  Generators.Idx()  \u2013 Get/Set\u00a0active\u00a0Generator\u00a0by\u00a0index\u00a0into\u00a0generators\u00a0list.\u00a0\u00a01..Count  Generators.Idx(arg)  \u2013 Set\u00a0active\u00a0Generator\u00a0by\u00a0index\u00a0into\u00a0generators\u00a0list.\u00a0\u00a01..Count  Generators.Model()  \u2013 Generator model  Generators.Model(arg)  \u2013 Set the Generator model  Generators.kV()  \u2013 Voltage\u00a0base\u00a0for\u00a0the\u00a0active\u00a0generator,\u00a0kV  Generators.kV(arg)  \u2013 Set the voltage\u00a0base\u00a0for\u00a0the\u00a0active\u00a0generator,\u00a0kV  Generators.kW()  \u2013 kW\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0kvar\u00a0is\u00a0updated\u00a0for\u00a0current\u00a0power\u00a0factor.  Generators.kW(arg)  \u2013 Set the kW\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0kvar\u00a0is\u00a0updated\u00a0for\u00a0current\u00a0power\u00a0factor.  Generators.kvar()  \u2013 kvar\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0Updates\u00a0power\u00a0factor\u00a0based\u00a0on\u00a0present\u00a0kW value.  Generators.kvar(arg)  \u2013 Set the kvar\u00a0output\u00a0for\u00a0the\u00a0active\u00a0generator.\u00a0Updates\u00a0power\u00a0factor\u00a0based\u00a0on\u00a0present\u00a0kW value.  Generators.PF()  \u2013 Power\u00a0factor\u00a0(pos.\u00a0=\u00a0producing\u00a0vars)  Generators.PF(arg)  \u2013 Set the power\u00a0factor\u00a0(pos.\u00a0=\u00a0producing\u00a0vars)  Generators.kVARated()  \u2013 Get the KVA rating of the generator.  Generators.kVARated(arg)  \u2013 Set the KVA rating of the generator.  Generators.Vmaxpu()  \u2013 Get the Vmaxpu for Generator Model.  Generators.Vmaxpu(arg)  \u2013 Set the Vmaxpu for Generator Model.  Generators.Vminpu()  \u2013 Get the Vminpu for Generator Model.  Generators.Vminpu(arg)  \u2013 Set the Vminpu for Generator Model.  Generators.Name()  \u2013 Active generator name.  Generators.Name(arg)  \u2013 Sets\u00a0a\u00a0generator\u00a0active\u00a0by\u00a0name.  Generators.AllNames()  \u2013 All generator names  Generators.RegisterNames()  \u2013 Array\u00a0of\u00a0Names\u00a0of\u00a0all\u00a0generator\u00a0energy\u00a0meter\u00a0registers  Generators.RegisterValues()  \u2013 Array\u00a0of\u00a0valus\u00a0in\u00a0generator\u00a0energy\u00a0meter\u00a0registers.", 
            "title": "Generators"
        }, 
        {
            "location": "/api/#isource", 
            "text": "# OpenDSSDirect.DSS.Isource     Module .   module Isource  \u2013 Functions for interfacing with the active OpenDSS current source.  Isource.Count()  \u2013 Returns the number of Isource objects currently defined in the active circuit.  Isource.First()  \u2013 Set the first ISource to be active; returns 0 if none.  Isource.Next()  \u2013 Set the next ISource to be active; returns 0 if none.  Isource.Amps()  \u2013 Get the magnitude of the Isource in Amps.  Isource.Amps(arg)  \u2013 Set the magnitude of the Isource in Amps.  Isource.AngleDeg()  \u2013 Get the phase angle of the Isource in degrees.  Isource.AngleDeg(arg)  \u2013 Set the phase angle of the Isource in degrees.  Isource.Frequency()  \u2013 Get the frequency of the Isource in Hz.  Isource.Frequency(arg)  \u2013 Set the frequency of the Isource in Hz.  Isource.Name()  \u2013 Get the name of the active Isource object.  Isource.Name(arg)  \u2013 Set the name of the active Isource object.  Isource.AllNames()  \u2013 Names of all Isources in the circuit.", 
            "title": "Isource"
        }, 
        {
            "location": "/api/#lines", 
            "text": "# OpenDSSDirect.DSS.Lines     Module .   module Lines  \u2013 Functions for interfacing with the active OpenDSS Line.  Lines.First()  \u2013 Set the first element active. Returns 0 if no Lines. Otherwise, index of the line element.  Lines.Next()  \u2013 Set the next element active. Returns 0 if no Lines. Otherwise, index of the line element.  Lines.Phases()  \u2013 Get the number of phases of the active line object.  Lines.Phases(arg)  \u2013 Set the number of phases of the active line object.  Lines.NumCust()  \u2013 Get the number of customers on this line section.  Lines.Parent()  \u2013 Get the parents of the active Line to be the active Line. Return 0 if no parent or action fails.  Lines.Count()  \u2013 Get the number of Line Objects in Active Circuit.  Lines.Units()  \u2013 Get the units of the line (distance, check manual for details).  Lines.Units(arg)  \u2013 Set the units of the line (distance, check manual for details).  Lines.Length()  \u2013 Get the length of line section in units compatible with the LineCode definition.  Lines.Length(arg)  \u2013 Set the length of line section in units compatible with the LineCode definition.  Lines.R1()  \u2013 Get the positive sequence resistance, ohm per unit length.  Lines.R1(arg)  \u2013 Set the positive sequence resistance, ohm per unit length.  Lines.X1()  \u2013 Get the positive sequence reactance, ohm per unit length.  Lines.X1(arg)  \u2013 Set the positive sequence reactance, ohm per unit length.  Lines.R0()  \u2013 Get the zero sequence resistance, ohm per unit length.  Lines.R0(arg)  \u2013 Set the zero sequence resistance, ohm per unit length.  Lines.X0()  \u2013 Get the zero sequence reactance, ohm per unit length.  Lines.X0(arg)  \u2013 Set the zero sequence reactance, ohm per unit length.  Lines.C1()  \u2013 Get the positive sequence capacitance, nanofarads per unit length.  Lines.C1(arg)  \u2013 Set the positive sequence capacitance, nanofarads per unit length.  Lines.C0()  \u2013 Get the zero sequence capacitance, nanofarads per unit length.  Lines.C0(arg)  \u2013 Set the zero sequence capacitance, nanofarads per unit length.  Lines.NormAmps()  \u2013 Get the normal ampere rating of Line.  Lines.NormAmps(arg)  \u2013 Set the normal ampere rating of Line.  Lines.EmergAmps()  \u2013 Get the emergency (maximum) ampere rating of Line.  Lines.EmergAmps(arg)  \u2013 Set the emergency (maximum) ampere rating of Line.  Lines.Rg()  \u2013 Get the earth return value used to compute line impedances at power frequency.  Lines.Rg(arg)  \u2013 Set the earth return value used to compute line impedances at power frequency.  Lines.Xg()  \u2013 Get the earth return reactance value used to compute line impedances at power frequency.  Lines.Xg(arg)  \u2013 Set the earth return reactance value used to compute line impedances at power frequency.  Lines.Rho()  \u2013 Get the earth resistivity, m-ohms.  Lines.Rho(arg)  \u2013 Set the earth resistivity, m-ohms.  Lines.Name()  \u2013 Get the name of the active Line element.  Lines.Name(arg)  \u2013 Set the name of the Line element to set it active.  Lines.Bus1()  \u2013 Get the name of bus for terminal 1.  Lines.Bus1(arg)  \u2013 Set the name of bus for terminal 1.  Lines.Bus2()  \u2013 Get the name of bus for terminal 2.  Lines.Bus2(arg)  \u2013 Set the name of bus for terminal 2.  Lines.LineCode()  \u2013 Get the name of LineCode object that defines the impedances.  Lines.LineCode(arg)  \u2013 Set the name of LineCode object that defines the impedances.  Lines.Geometry()  \u2013 Get the name of the Line geometry code.  Lines.Geometry(arg)  \u2013 Set the name of the Line geometry code.  Lines.Spacing()  \u2013 Get the name of the Line spacing code.  Lines.Spacing(arg)  \u2013 Set the name of the Line spacing code.  Lines.AllNames()  \u2013 Get the name of all Line Objects.  Lines.RMatrix()  \u2013 Get the resistance matrix (full), ohms per unit length. Variant array of doubles.  Lines.XMatrix()  \u2013 Get the reactance matrix (full), ohms per unit length. Variant array of doubles.  Lines.CMatrix()  \u2013 Get the capacitance matrix (full), nanofarads per unit length. Variant array of doubles.  Lines.Yprim()  \u2013 Get the YPrimitive of the active Line.", 
            "title": "Lines"
        }, 
        {
            "location": "/api/#loads", 
            "text": "# OpenDSSDirect.DSS.Loads     Module .   module Loads  \u2013 Functions for interfacing with the active OpenDSS load.  Loads.First()  \u2013 Allows to set the active load into the first load registered in the active circuit. As a result, this property will return the number 1. The parameter argument can be filled with a 0.  Loads.Next()  \u2013 Set the active load into the next load registered in the active circuit. As a result, this property will set the index of the active load. The parameter argument can be filled with a 0.  Loads.Idx()  \u2013 The index of the active load. The parameter argument can be filled with a 0.  Loads.Idx(arg)  \u2013 Set the index of the active load. The parameter argument must contain the index of the desired active load. The return value will be equal to 0.  Loads.Count()  \u2013 Returns the number of load elements within the active circuit. The parameter argument can be filled with a 0.  Loads.Class()  \u2013 The code number used to separate Loads by class or group. The parameter argument can be filled with a 0.  Loads.Class(arg)  \u2013 The code number used to separate loads by class or group. The parameter argument can be filled with a 0.  Loads.Model()  \u2013 The model of the active load. The parameter argument can be filled with a 0.  Loads.Model(arg)  \u2013 Set the model of the active load using the parameter argument. return a 0.  Loads.NumCust()  \u2013 The number of customer of the active load. The parameter argument can be filled with a 0.  Loads.NumCust(arg)  \u2013 Set the number of customers of the active load using the parameter argument. return a 0.  Loads.Status()  \u2013   Loads.Status(arg)  \u2013   Loads.IsDelta()  \u2013 If true, loads are line to line.  Loads.IsDelta(arg)  \u2013 Set whether loads are delta (line to line).  Loads.kW()  \u2013 The kW property of the active load. The parameter argument can be filled with a 0.  Loads.kW(arg)  \u2013 Set the kW property of the active load. The parameter argument must contain the new value in kW for the desired active load. The return value will be equal to 0.  Loads.kV()  \u2013 The kV property of the active load. The parameter argument can be filled with a 0.  Loads.kV(arg)  \u2013 Set the kV property of the active load. The parameter argument must contain the new value in kV for the desired active load. The return value will be equal to 0.  Loads.kvar()  \u2013 The kvar property of the active load. The parameter argument can be filled with a 0.  Loads.kvar(arg)  \u2013 Set the kvar property of the active load. The parameter argument must contain the new value in kvar for the desired active load. The return value will be equal to 0.  Loads.PF()  \u2013 The pf property of the active load. The parameter argument can be filled with a 0.  Loads.PF(arg)  \u2013 Set the pf property of the active load. The parameter argument must contain the new value in pf for the desired active load. The return value will be equal to 0.  Loads.PctMean()  \u2013 The PctMean property of the active load. The parameter argument can be filled with a 0.  Loads.PctMean(arg)  \u2013 Set the PctMean property of the active load. The parameter argument must contain the new value in PctMean for the desired active load. The return value will be equal to 0.  Loads.PctStdDev()  \u2013 The PctStdDev property of the active load. The parameter argument can be filled with a 0.  Loads.PctStdDev(arg)  \u2013 Set the PctStdDev property of the active load. The parameter argument must contain the new value in PctStdDev for the desired active load. The return value will be equal to 0.  Loads.AllocationFactor()  \u2013 The AllocationFactor property of the active load. The parameter argument can be filled with a 0.  Loads.AllocationFactor(arg)  \u2013 Set the AllocationFactor property of the active load. The parameter argument must contain the new value in AllocationFactor for the desired active load. The return value will be equal to 0.  Loads.CFactor()  \u2013 The CFactor property of the active load. The parameter argument can be filled with a 0.  Loads.CFactor(arg)  \u2013 Set the CFactor property of the active load. The parameter argument must contain the new value in CFactor for the desired active load. The return value will be equal to 0.  Loads.CVRwatts()  \u2013 The CVRWatts property of the active load. The parameter argument can be filled with a 0.  Loads.CVRwatts(arg)  \u2013 Set the CVRWatts property of the active load. The parameter argument must contain the new value in CVRWatts for the desired active load. The return value will be equal to 0.  Loads.CVRvars()  \u2013 The CVRvars property of the active load. The parameter argument can be filled with a 0.  Loads.CVRvars(arg)  \u2013 Set the CVRvars property of the active load. The parameter argument must contain the new value in CVRvars for the desired active load. The return value will be equal to 0.  Loads.kVABase()  \u2013 The kva property of the active load. The parameter argument can be filled with a 0.  Loads.kVABase(arg)  \u2013 Set the kva property of the active load. The parameter argument must contain the new value in kva for the desired active load. The return value will be equal to 0.  Loads.kWh()  \u2013 The kWh property of the active load. The parameter argument can be filled with a 0.  Loads.kWh(arg)  \u2013 Set the kWh property of the active load. The parameter argument must contain the new value in kWh for the desired active load. The return value will be equal to 0.  Loads.kWhDays()  \u2013 The kWhdays property of the active load. The parameter argument can be filled with a 0.  Loads.kWhDays(arg)  \u2013 Set the kWhdays property of the active load. The parameter argument must contain the new value in kWhdays for the desired active load. The return value will be equal to 0.  Loads.Rneut()  \u2013 The RNeut (neutral resistance for wye connected loads) property of the active load. The parameter argument can be filled with a 0.  Loads.Rneut(arg)  \u2013 Set the RNeut (neutral resistance for wye connected loads) property of the active load. The parameter argument must contain the new value in RNeut for the desired active load. The return value will be equal to 0.  Loads.Vmaxpu()  \u2013 The VMaxpu property of the active load. The parameter argument can be filled with a 0.  Loads.Vmaxpu(arg)  \u2013 Set the VMaxpu property of the active load. The parameter argument must contain the new value in VMaxpu for the desired active load. The return value will be equal to 0.  Loads.VminEmerg()  \u2013 The VMinemerg property of the active load. The parameter argument can be filled with a 0.  Loads.VminEmerg(arg)  \u2013 Set the VMinemerg property of the active load. The parameter argument must contain the new value in VMinemerg for the desired active load. The return value will be equal to 0.  Loads.VminNorm()  \u2013 The VMinnorm property of the active load. The parameter argument can be filled with a 0.  Loads.VminNorm(arg)  \u2013 Set the VMinnorm property of the active load. The parameter argument must contain the new value in VMinnorm for the desired active load. The return value will be equal to 0.  Loads.Vminpu()  \u2013 The VMinpu property of the active load. The parameter argument can be filled with a 0.  Loads.Vminpu(arg)  \u2013 Set the VMinpu property of the active load. The parameter argument must contain the new value in VMinpu for the desired active load. The return value will be equal to 0.  Loads.XfkVA()  \u2013 The xfKVA (Rated service transformer KVA for load allocation, using Allocationfactor. Affects kW, kvar and pf.) property of the active load. The parameter argument can be filled with a 0.  Loads.XfkVA(arg)  \u2013 Set the xfKVA (Rated service transformer KVA for load allocation, using Allocationfactor. Affects kW, kvar and pf.) property of the active load. The parameter argument must contain the new value in xfKVA for the desired active load. The return value will be equal to 0.  Loads.Xneut()  \u2013 The Xneut property of the active load. The parameter argument can be filled with a 0.  Loads.Xneut(arg)  \u2013 Set the Xneut property of the active load. The parameter argument must contain the new value in Xneut for the desired active load. The return value will be equal to 0.  Loads.puSeriesRL()  \u2013 The PctSeriesRL (Percent of Load that is modeled as series R-L for harmonic studies) property of the active load. The parameter argument can be filled with a 0.  Loads.puSeriesRL(arg)  \u2013 Set the PctSeriesRL (Percent of Load that is modeled as series R-L for harmonic studies) property of the active load. The parameter argument must contain the new value in PctSeriesRL for the desired active load. The return value will be equal to 0.  Loads.RelWeighting()  \u2013 The RelWeight (relative weighting factor) property of the active load. The parameter argument can be filled with a 0.  Loads.RelWeighting(arg)  \u2013 Set the RelWeight (relative weighting factor) property of the active load. The parameter argument must contain the new value in RelWeight for the desired active load. The return value will be equal to 0.  Loads.Name()  \u2013 The Name property of the active load. The parameter argument can be filled with an empty string.  Loads.Name(arg)  \u2013 Set the active load by specifying the Name load. The parameter argument must contain the Name of the load to activate. The return value will be equal to empty.  Loads.CVRCurve()  \u2013 The CVRCUrve property of the active load. The parameter argument can be filled with an empty string.  Loads.CVRCurve(arg)  \u2013 Set the CVRCurve property for the active load. The parameter argument must contain the Name of the new CVRCurve to be linked to the active load. The return value will be equal to empty.  Loads.Daily()  \u2013 The daily property of the active load. The parameter argument can be filled with an empty string.  Loads.Daily(arg)  \u2013 Set the daily property for the active load. The parameter argument must contain the Name of the new daily to be linked to the active load. The return value will be equal to empty.  Loads.Duty()  \u2013 The duty property of the active load. The parameter argument can be filled with an empty string.  Loads.Duty(arg)  \u2013 Set the duty property for the active load. The parameter argument must contain the Name of the new duty to be linked to the active load. The return value will be equal to empty.  Loads.Spectrum()  \u2013 The Spectrum property of the active load. The parameter argument can be filled with an empty string.  Loads.Spectrum(arg)  \u2013 Set the Spectrum property for the active load. The parameter argument must contain the Name of the new Spectrum to be linked to the active load. The return value will be equal to empty.  Loads.Yearly()  \u2013 The Yearly property of the active load. The parameter argument can be filled with an empty string.  Loads.Yearly(arg)  \u2013 Set the Yearly property for the active load. The parameter argument must contain the Name of the new Yearly to be linked to the active load. The return value will be equal to empty.  Loads.Growth()  \u2013 The Growth property of the active load. The parameter argument can be filled with an empty string.  Loads.Growth(arg)  \u2013 Set the Growth property for the active load. The parameter argument must contain the Name of the new Growth to be linked to the active load. The return value will be equal to empty.  Loads.AllNames()  \u2013 The names of all the loads present in the active circuit. The result is delivered as variant, however, the content of this variant is an array of strings.  Loads.ZipV()  \u2013 The array of 7 elements (doubles) for ZIP property of the active Load object.", 
            "title": "Loads"
        }, 
        {
            "location": "/api/#loadshape", 
            "text": "# OpenDSSDirect.DSS.LoadShape     Module .   module LoadShape  \u2013 Functions for interfacing with the active OpenDSS LoadShape.  LoadShape.Count()  \u2013 The number of LoadShape objects currently defined in LoadShape collection.  LoadShape.First()  \u2013 Set the first LoadShape active and return integer index of the LoadShape. Returns 0 if no more.  LoadShape.Next()  \u2013 Set the next LoadShape active and return integer index of the LoadShape. Returns 0 if no more.  LoadShape.Npts()  \u2013 Get the number of points in active LoadShape.  LoadShape.Npts(arg)  \u2013 Set the number of points in active LoadShape.  LoadShape.Normalize()  \u2013 normalizes the P and Q curves based on either Pbase, Qbase or simply the peak value of the curve.  LoadShape.UseActual()  \u2013 Get a TRUE/FALSE (1/0) to let Loads know to use the actual value in the curve rather than use the value as a multiplier.  LoadShape.UseActual(arg)  \u2013 Set a TRUE/FALSE (1/0 - Argument) to let Loads know to use the actual value in the curve rather than use the value as a multiplier.  LoadShape.HrInterval()  \u2013 Get the fixed interval time value, hours.  LoadShape.HrInterval(arg)  \u2013 Set the fixed interval time value, hours.  LoadShape.MinInterval()  \u2013 Get the fixed interval time value, in minutes.  LoadShape.MinInterval(arg)  \u2013 Set the fixed interval time value, in minutes.  LoadShape.PBase()  \u2013 Get the base for normalizing P curve. If left at zero, the peak value is used.  LoadShape.PBase(arg)  \u2013 Set the base for normalizing P curve. If left at zero, the peak value is used.  LoadShape.QBase()  \u2013 Get the base for normalizing Q curve. If left at zero, the peak value is used.  LoadShape.QBase(arg)  \u2013 Set the base for normalizing Q curve. If left at zero, the peak value is used.  LoadShape.SInterval()  \u2013 Get the fixed interval data time interval, seconds.  LoadShape.SInterval(arg)  \u2013 Set the fixed interval data time interval, seconds.  LoadShape.Name()  \u2013 Get the name of the active LoadShape object.  LoadShape.Name(arg)  \u2013 Set the name of the active LoadShape object.  LoadShape.AllNames()  \u2013 Names of all of the load shapes  LoadShape.PMult()  \u2013 Get a variant array of doubles for the P multiplier in the LoadShape.  LoadShape.QMult()  \u2013 Get a variant array of doubles for the Q multiplier in the LoadShape.  LoadShape.TimeArray()  \u2013 Get a time array in hours corresponding to P and Q multipliers when the Interval = 0.", 
            "title": "LoadShape"
        }, 
        {
            "location": "/api/#meters", 
            "text": "# OpenDSSDirect.DSS.Meters     Module .   module Meters  \u2013 Functions for interfacing with the active OpenDSS energy meter.  Meters.First()  \u2013 Set the first Energy Meter active. Returns 0 if no Monitors.  Meters.Next()  \u2013 Set the next energy Meter Active. Returns 0 if no more.  Meters.Reset()  \u2013 Resets the active Meter object.  Meters.ResetAll()  \u2013 Resets all Meter object.  Meters.Sample()  \u2013 Causes active meter to take a sample.  Meters.Save()  \u2013 Causes active meter to save its current sample buffer to its meter stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.  Meters.MeteredTerminal()  \u2013 The number of metered terminal by the active Energy Meter.  Meters.MeteredTerminal(arg)  \u2013 Set the number of metered terminal by the active Energy Meter.  Meters.DIFilesAreOpen()  \u2013 Returns a global flag (1=true, 0=false) to indicate if Demand Interval (DI) files have been properly opened.  Meters.SampleAll()  \u2013 Causes all Energy Meters to take a sample of the present state. Returns 0.  Meters.SaveAll()  \u2013 save all Energy Meter buffers to their respective file streams. Returns 0.  Meters.OpenAllDIFiles()  \u2013 Opens Demand Interval (DI) files. Returns 0.  Meters.CloseAllDIFiles()  \u2013 Close all Demand Interval (DI) files. Necessary at the end of a run.  Meters.CountEndElements()  \u2013 The number of zone end elements in the active meter zone.  Meters.Count()  \u2013 The number of Energy Meters in the Active Circuit.  Meters.CountBranches()  \u2013 The number of branches in active Energy Meter zone (same as sequencelist size).  Meters.SequenceList()  \u2013 The index into meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be up line from later index. Sets PDElement active.  Meters.SequenceList(arg)  \u2013 Set the index into meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be up line from later index. Sets PDElement active.  Meters.DoReliabilityCalc(arg)  \u2013 calculates SAIFI, etc. if the Argument is equal to 1 assume restoration, otherwise it will not.  Meters.SeqListSize()  \u2013 The size of Sequence List.  Meters.TotalCustomers()  \u2013 The total number of customers in this zone (down line from the Energy Meter).  Meters.NumSections()  \u2013 The number of feeder sections in this meter's zone.  Meters.SetActiveSection(arg)  \u2013 Set the designated section (argument) if the index is valid.  Meters.OCPDeviceType()  \u2013 The type of OCP device: {1=fuse | 2+ recloser | 3= relay}.  Meters.NumSectionCustomers()  \u2013 The number of customers in the active section.  Meters.NumSectionBranches()  \u2013 The number of branches (Lines) in the active section.  Meters.SectSeqidx()  \u2013 The Sequence Index of the branch at the head of this section.  Meters.SectTotalCust()  \u2013 The total customers down line from this section.  Meters.SAIFI()  \u2013 SAIFI for this meter's zone. Execute reliability calc method first.  Meters.SAIFIkW()  \u2013 The SAIFI based on kW rather than number of customers. Get after reliability calcs.  Meters.SAIDI()  \u2013 The SAIDI for this meter zone. Execute DoreliabilityCalc first.  Meters.CustInterrupts()  \u2013 The total customer interruptions for this meter zone based on reliability calcs.  Meters.AvgRepairTime()  \u2013 The average Repair Time in this Section of the meter zone.  Meters.FaultRateXRepairHrs()  \u2013 The sum of Fault Rate time Repair Hours in this section of the meter zone.  Meters.SumBranchFltRates()  \u2013 The sum of the branch fault rates in this section of the meter's zone.  Meters.Name()  \u2013 The active Energy Meter's name.  Meters.Name(arg)  \u2013 Set the active Energy Meter's name.  Meters.MeteredElement()  \u2013 The name of the metered element (considering the active Energy Meter).  Meters.MeteredElement(arg)  \u2013 Set the name of the metered element (considering the active Energy Meter).  Meters.AllNames()  \u2013 All Energy Meter names.  Meters.RegisterNames()  \u2013 Strings containing the names of the registers.  Meters.RegisterValues(arg)  \u2013 Values contained in the Meter registers for the active Meter.  Meters.Totals()  \u2013 The totals for all registers of all Meters.  Meters.PeakCurrent()  \u2013 Returns an array of doubles with the Peak Current Property.  Meters.CalcCurrent()  \u2013 The magnitude of the real part of the Calculated Current (normally determined by solution) for the meter to force some behavior on Load Allocation.  Meters.AllocFactors()  \u2013 An array of doubles: allocation factors for the active Meter.  Meters.AllEndElements()  \u2013 A vector of names of all zone end elements.  Meters.AllBranchesInZone()  \u2013 A wide string list of all branches in zone of the active Energy Meter object.", 
            "title": "Meters"
        }, 
        {
            "location": "/api/#monitors", 
            "text": "# OpenDSSDirect.DSS.Monitors     Module .   module Monitors  \u2013 Functions for interfacing with the active OpenDSS Monitor.  Monitors.First()  \u2013 Set the first monitor active. Returns 0 if no Monitors.  Monitors.Next()  \u2013 Set the next monitor active. Returns 0 if no more.  Monitors.Reset()  \u2013 Resets the active Monitor object.  Monitors.ResetAll()  \u2013 Resets all Monitor object.  Monitors.Sample()  \u2013 Causes active monitor to take a sample.  Monitors.Save()  \u2013 Causes active monitor to save its current sample buffer to its monitor stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.  Monitors.Show()  \u2013 Converts monitor file into text and displays with text editor.  Monitors.Mode()  \u2013 The monitor mode (bitmask integer - see DSS Help).  Monitors.Mode(arg)  \u2013 Set the monitor mode (bitmask integer - see DSS Help).  Monitors.SampleCount()  \u2013 Returns number of samples in Monitor at present.  Monitors.SampleAll()  \u2013 Causes all Monitors to take a sample of the present state. Returns 0.  Monitors.SaveAll()  \u2013 Save all Monitor buffers to their respective file streams. Returns 0.  Monitors.Count()  \u2013 The number of Monitors.  Monitors.Process()  \u2013 Post-process monitor samples taken so far, e.g., Pst for mode = 4.  Monitors.ProcessAll()  \u2013 Makes that all Monitors post-process the data taken so far.  Monitors.FileVersion()  \u2013 The Monitor File version (integer).  Monitors.RecordSize()  \u2013 The size of each record in ByteStream.  Monitors.NumChannels()  \u2013 The number of Channels on the active Monitor.  Monitors.Terminal()  \u2013 The terminal number of element being monitored.  Monitors.Terminal(arg)  \u2013 Set the terminal number of element being monitored.  Monitors.FileName()  \u2013 The name of the CSV file associated with active monitor.  Monitors.Name()  \u2013 The active Monitor object by name.  Monitors.Name(arg)  \u2013 Set the active Monitor object by name.  Monitors.Element()  \u2013 The full name of element being monitored by the active Monitor.  Monitors.Element(arg)  \u2013 Set the full name of element being monitored by the active Monitor.  Monitors.AllNames()  \u2013 An array of all Monitor names (array of strings).  Monitors.ByteStream()  \u2013 \"A byte array containing monitor stream values. Make sure a \" * @save_str(\" is done first (standard solution modes do this automatically).\")  Monitors.DblHourS()  \u2013 The header string; vector of strings containing Channel Names.  Monitors.DblHour()  \u2013 A vector of doubles containing time value in hours for the time-sampled monitor values; empty if frequency-sampled values for harmonics solution (see dblFreq).  Monitors.DblFreqS()  \u2013 A vector of doubles containing time values for harmonics mode solutions; empty for time mode solutions (use dblHour).  Monitors.DblFreq()  \u2013 A vector of doubles for the specified channel (usage: MyArray = DSSmonitor.Channel(i)) A save or SaveAll should be executed first. Done automatically by most standard solution modes.", 
            "title": "Monitors"
        }, 
        {
            "location": "/api/#parser", 
            "text": "# OpenDSSDirect.DSS.Parser     Module .   module Parser  \u2013 Functions for interfacing with the OpenDSS Parser.  Parser.IntValue()  \u2013 Return next parameter as a long integer.  Parser.ResetDelimiters()  \u2013 Reset delimiters to their default values.  Parser.AutoIncrement()  \u2013 In the default is false (0). If true (1) Parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.  Parser.AutoIncrement(arg)  \u2013 In the default is false (0). If true (1) Parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.  Parser.DblValue()  \u2013 Returns next parameter as a double.  Parser.CmdString()  \u2013 Get a string to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.  Parser.CmdString(arg)  \u2013 Set a string to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.  Parser.NextParam()  \u2013 Get next token and return tag name (before = sign) if any. See Autoincrement.  Parser.StrValue()  \u2013 Return next parameter as a string.  Parser.WhiteSpace()  \u2013 Get the characters used for White space in the command string. Default in blank and Tab.  Parser.WhiteSpace(arg)  \u2013 Set the characters used for White space in the command string. Default in blank and Tab.  Parser.BeginQuote()  \u2013 Get the string containing the characters for quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"([{.  Parser.BeginQuote(arg)  \u2013 Set the string containing the characters for quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"([{.  Parser.EndQuote()  \u2013 Get the string containing the characters, in order, that match the beginning quote characters in BeginQuote. Default is \")]}.  Parser.EndQuote(arg)  \u2013 Set the string containing the characters, in order, that match the beginning quote characters in BeginQuote. Default is \")]}.  Parser.Delimiters()  \u2013 Get the string defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitespace to separate tokens.  Parser.Delimiters(arg)  \u2013 Set the string defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitespace to separate tokens.  Parser.Vector()  \u2013 Returns token as vector of doubles. For parsing quoted array syntax.  Parser.Matrix()  \u2013 Use this property to parse a Matrix token in OpenDSS format. Returns square matrix of order specified. Order same as default fortran order: column by column.  Parser.SymMatrix()  \u2013 Use this property to parse a Matrix token in lower triangular form. Symmetry is forced.", 
            "title": "Parser"
        }, 
        {
            "location": "/api/#pdelements", 
            "text": "# OpenDSSDirect.DSS.PDElements     Module .   module PDElements  \u2013 Functions for interfacing with the active OpenDSS power-delivery element.  PDElements.Count()  \u2013 Get number of PDElements in active circuit.  PDElements.First()  \u2013 Set the first enabled PD element to be the active element. Returns 0 if none found.  PDElements.Next()  \u2013 Set the next enabled PD element to be the active element. Returns 0 if none found.  PDElements.IsShunt()  \u2013 returns 1 if the PD element should be treated as a shunt element rather than a series element. Applies to capacitor and reactor elements in particular.  PDElements.NumCustomers()  \u2013 Get the number of customers in this branch.  PDElements.TotalCustomers()  \u2013 Get the total number of customers from this branch to the end of the zone.  PDElements.ParentPDElement()  \u2013 Set the parent PD element to be the active circuit element. Returns 0 if no more elements upline.  PDElements.FromTerminal()  \u2013 \"Get the number of the terminal of active PD element that is on the \" * @from_str(\" side. This is set after the meter zone is determined.\")  PDElements.SectionID()  \u2013 Get the integer ID of the feeder section that this PDElement branch is part of.  PDElements.FaultRate()  \u2013 Get the number of failures per year. For LINE elements: Number of failures per unit length per year.  PDElements.FaultRate(arg)  \u2013 Set the number of failures per year. For LINE elements: Number of failures per unit length per year.  PDElements.PctPermanent()  \u2013 Get the percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.  PDElements.PctPermanent(arg)  \u2013 Set the percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.  PDElements.Lambda()  \u2013 Get the failure rate for this branch. Faults per year including length of line.  PDElements.AccumulatedL()  \u2013 Get the accumulated failure rate for this branch on down line.  PDElements.RepairTime()  \u2013 Get the average time to repair a permanent fault on this branch, hours.  PDElements.TotalMiles()  \u2013 Get the total miles of line from this element to the end of the zone. For recloser siting algorithm.  PDElements.Name()  \u2013 Get the name of the active PDElement, returns null string if active element id not PDElement.  PDElements.Name(arg)  \u2013 Set the name of the active PDElement, returns null string if active element id not PDElement.", 
            "title": "PDElements"
        }, 
        {
            "location": "/api/#progress", 
            "text": "# OpenDSSDirect.DSS.Progress     Module .   module Progress  \u2013 Functions for controlling the progress form.  Progress.PctProgress()  \u2013 Percent\u00a0Progress\u00a0to\u00a0indicate\u00a0[0..100]  Progress.Show()  \u2013 Shows\u00a0Progress\u00a0form\u00a0with\u00a0null\u00a0caption\u00a0and\u00a0Progress\u00a0set\u00a0to\u00a0zero.  Progress.Close()  \u2013 Close the Progress form.  Progress.Caption()  \u2013 Caption\u00a0to\u00a0appear\u00a0on\u00a0the\u00a0bottom\u00a0of\u00a0the\u00a0DSS\u00a0Progress\u00a0form.", 
            "title": "Progress"
        }, 
        {
            "location": "/api/#properties", 
            "text": "# OpenDSSDirect.DSS.Properties     Module .   module Properties  \u2013 Functions for interfacing with OpenDSS properties.  Properties.Name()  \u2013 The name of the active property.  Properties.Description()  \u2013 The description of the active property.  Properties.Value()  \u2013 The value of the active property.  Properties.Value(arg)  \u2013 Set the value of the active property. The new value must be specified in  arg  as a string.", 
            "title": "Properties"
        }, 
        {
            "location": "/api/#pvsystems", 
            "text": "# OpenDSSDirect.DSS.PVsystems     Module .   module PVsystems  \u2013 Functions for interfacing with the active OpenDSS PVsystem.  PVsystems.Count()  \u2013 The number of PVSystem objects currently defined in the active circuit.  PVsystems.First()  \u2013 Set the first PVSystem to be active; returns 0 if none.  PVsystems.Next()  \u2013 Set the next PVSystem to be active; returns 0 if none.  PVsystems.Idx()  \u2013 Get the active PVSystem by index; 1..Count.  PVsystems.Idx(arg)  \u2013 Set the active PVSystem by index; 1..Count.  PVsystems.Irradiance()  \u2013 Get the present value of the Irradiance property in W/sq-m.  PVsystems.Irradiance(arg)  \u2013 Set the present value of the Irradiance property in W/sq-m.  PVsystems.kW()  \u2013 Get the kW output.  PVsystems.kvar()  \u2013 Get the kvar value.  PVsystems.kvar(arg)  \u2013 Set the kvar value.  PVsystems.pf()  \u2013 Get the power factor value.  PVsystems.pf(arg)  \u2013 Set the power factor value.  PVsystems.kVARated()  \u2013 Get the rated kVA.  PVsystems.kVARated(arg)  \u2013 Set the rated kVA.", 
            "title": "PVsystems"
        }, 
        {
            "location": "/api/#reclosers", 
            "text": "# OpenDSSDirect.DSS.Reclosers     Module .   module Reclosers  \u2013 Functions for interfacing with the active OpenDSS Recloser.  Reclosers.Count()  \u2013 Get number of Reclosers in active circuit.  Reclosers.First()  \u2013 Set first recloser to be active Circuit Element. Returns 0 if none.  Reclosers.Next()  \u2013 Set next recloser to be active Circuit Element. Returns 0 if none.  Reclosers.MonitoredTerm()  \u2013 Get the terminal number of Monitored Object for the Recloser.  Reclosers.MonitoredTerm(arg)  \u2013 Set the terminal number of Monitored Object for the Recloser.  Reclosers.SwitchedTerm()  \u2013 Get the terminal of the controlled device being switched by the Recloser.  Reclosers.SwitchedTerm(arg)  \u2013 Set the terminal of the controlled device being switched by the Recloser.  Reclosers.NumFast()  \u2013 Get the number of fast shots.  Reclosers.NumFast(arg)  \u2013 Set the number of fast shots.  Reclosers.Shots()  \u2013 Get the number of shots to lockout (fast + delayed).  Reclosers.Shots(arg)  \u2013 Set the number of shots to lockout (fast + delayed).  Reclosers.Open()  \u2013 Open recloser's controlled element and lock out the recloser.  Reclosers.Close()  \u2013 Close the switched object controlled by the recloser. Resets recloser to first operation.  Reclosers.Idx()  \u2013 Get the active recloser by index into the recloser list. 1..Count.  Reclosers.Idx(arg)  \u2013 Set the active recloser by index into the recloser list. 1..Count.  Reclosers.PhaseTrip()  \u2013 Get the phase trip curve multiplier or actual amps.  Reclosers.PhaseTrip(arg)  \u2013 Set the phase trip curve multiplier or actual amps.  Reclosers.PhaseInst()  \u2013 Get the phase instantaneous curve multiplier or actual amps.  Reclosers.PhaseInst(arg)  \u2013 Set the phase instantaneous curve multiplier or actual amps.  Reclosers.GroundTrip()  \u2013 Get the ground (3I0) trip multiplier or actual amps.  Reclosers.GroundTrip(arg)  \u2013 Set the ground (3I0) trip multiplier or actual amps.  Reclosers.GroundInst()  \u2013 Get the ground (3I0) instantaneous trip setting - curve multiplier or actual amps.  Reclosers.GroundInst(arg)  \u2013 Set the ground (3I0) instantaneous trip setting - curve multiplier or actual amps.  Reclosers.Name()  \u2013 Get the name of the active Recloser Object.  Reclosers.Name(arg)  \u2013 Set the name of the active Recloser Object.  Reclosers.MonitoredObj()  \u2013 Get the full name of object this Recloser is monitoring.  Reclosers.MonitoredObj(arg)  \u2013 Set the full name of object this Recloser is monitoring.  Reclosers.SwitchedObj()  \u2013 Get the full name of the circuit element that is being switched by this Recloser.  Reclosers.SwitchedObj(arg)  \u2013 Set the full name of the circuit element that is being switched by this Recloser.  Reclosers.AllNames()  \u2013 Get a vector of strings with names of all Reclosers in active circuit.  Reclosers.RecloseIntervals()  \u2013 Get a vector of doubles: reclose intervals (s) between shots.", 
            "title": "Reclosers"
        }, 
        {
            "location": "/api/#regcontrols", 
            "text": "# OpenDSSDirect.DSS.RegControls     Module .   module RegControls  \u2013 Functions for interfacing with the active OpenDSS RegControl.  RegControls.First()  \u2013 Set the first RegControl active. Returns 0 if no more.  RegControls.Next()  \u2013 Set the next RegControl active. Returns 0 if no more  RegControls.TapWinding()  \u2013 Get the tapped winding number.  RegControls.TapWinding(arg)  \u2013 Set the tapped winding number.  RegControls.Winding()  \u2013 Get the winding number for PT and CT connections.  RegControls.Winding(arg)  \u2013 Set the winding number for PT and CT connections.  RegControls.IsReversible()  \u2013 Get the setting in the reverse direction, usually not applicable to substation Transformers.  RegControls.IsReversible(arg)  \u2013 Set the different settings for the reverse direction (see Manual for details), usually not applicable to substation Transformers.  RegControls.IsInverseTime()  \u2013 Get the inverse time feature. Time delay is inversely adjusted, proportional to the amount of voltage outside the regulator band.  RegControls.IsInverseTime(arg)  \u2013 Set the inverse time feature. Time delay is inversely adjusted, proportional to the amount of voltage outside the regulator band.  RegControls.MaxTapChange()  \u2013 Get the maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for faster solution.  RegControls.MaxTapChange(arg)  \u2013 Set the maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for faster solution.  RegControls.Count()  \u2013 Get the number of RegControl objects in Active Circuit.  RegControls.TapNumber()  \u2013 Get the tap number.  RegControls.TapNumber(arg)  \u2013 Set the tap number.  RegControls.CTPrimary()  \u2013 Get the CT primary ampere rating (secondary is 0.2 amperes).  RegControls.CTPrimary(arg)  \u2013 Set the CT primary ampere rating (secondary is 0.2 amperes).  RegControls.PTRatio()  \u2013 Get the PT ratio for voltage control settings.  RegControls.PTRatio(arg)  \u2013 Set the PT ratio for voltage control settings.  RegControls.ForwardR()  \u2013 Get the LDC R settings in Volts.  RegControls.ForwardR(arg)  \u2013 Set the LDC R settings in Volts.  RegControls.ForwardX()  \u2013 Get the LDC X settings in Volts.  RegControls.ForwardX(arg)  \u2013 Set the LDC X settings in Volts.  RegControls.ReverseR()  \u2013 Get the reverse LDC R settings in Volts.  RegControls.ReverseR(arg)  \u2013 Set the reverse LDC R settings in Volts.  RegControls.ReverseX()  \u2013 Get the reverse LDC X settings in Volts.  RegControls.ReverseX(arg)  \u2013 Set the reverse LDC X settings in Volts.  RegControls.Delay()  \u2013 Get the time delay [s] after arming before the first tap change. Control may reset before actually changing taps.  RegControls.Delay(arg)  \u2013 Set the time delay [s] after arming before the first tap change. Control may reset before actually changing taps.  RegControls.TapDelay()  \u2013 Get the time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.  RegControls.TapDelay(arg)  \u2013 Set the time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.  RegControls.VoltageLimit()  \u2013 Get the first house voltage limit on PT secondary base. Setting to 0 disables this function.  RegControls.VoltageLimit(arg)  \u2013 Set the first house voltage limit on PT secondary base. Setting to 0 disables this function.  RegControls.ForwardBand()  \u2013 Get the regulation bandwidth in forward direction, centered on Vreg.  RegControls.ForwardBand(arg)  \u2013 Set the regulation bandwidth in forward direction, centered on Vreg.  RegControls.ForwardVreg()  \u2013 Get the target voltage in the forward direction, on PT secondary base.  RegControls.ForwardVreg(arg)  \u2013 Set the target voltage in the forward direction, on PT secondary base.  RegControls.ReverseBand()  \u2013 Get the bandwidth in reverse direction, centered on reverse Vreg.  RegControls.ReverseBand(arg)  \u2013 Set the bandwidth in reverse direction, centered on reverse Vreg.  RegControls.ReverseVreg()  \u2013 Get the target voltage in the reverse direction, on PT secondary base.  RegControls.ReverseVreg(arg)  \u2013 Set the target voltage in the reverse direction, on PT secondary base.  RegControls.Name()  \u2013 Get the active RegControl name.  RegControls.Name(arg)  \u2013 Set the active RegControl name.  RegControls.MonitoredBus()  \u2013 Get the name of the remote regulated bus, in lieu of LDC settings.  RegControls.MonitoredBus(arg)  \u2013 Set the name of the remote regulated bus, in lieu of LDC settings.  RegControls.Transformer()  \u2013 Get the name of the transformer this regulator controls.  RegControls.Transformer(arg)  \u2013 Set the name of the transformer this regulator controls.  RegControls.AllNames()  \u2013 Get a vector of strings containing all RegControl names.", 
            "title": "RegControls"
        }, 
        {
            "location": "/api/#relays", 
            "text": "# OpenDSSDirect.DSS.Relays     Module .   module Relays  \u2013 Functions for interfacing with the active OpenDSS Relay.  Relays.Count()  \u2013 Get number of Relays in active circuit.  Relays.First()  \u2013 Set first relay active. If none, returns 0.  Relays.Next()  \u2013 Set next relay active. If none, returns 0.  Relays.MonitoredTerm()  \u2013 Get the number of terminal of monitored element that this relay is monitoring.  Relays.MonitoredTerm(arg)  \u2013 Set the number of terminal of monitored element that this relay is monitoring.  Relays.SwitchedTerm()  \u2013 Get the number of terminal of the switched object that will be opened when the relay trips.  Relays.SwitchedTerm(arg)  \u2013 Set the number of terminal of the switched object that will be opened when the relay trips.  Relays.Idx()  \u2013 Get the active relay by index into the Relay list. 1..Count.  Relays.Idx(arg)  \u2013 Set the active relay by index into the Relay list. 1..Count.  Relays.Name()  \u2013 Get the name of the active Relay.  Relays.Name(arg)  \u2013 Set the name of the active Relay.  Relays.MonitoredObj()  \u2013 Get the full name of the object this relay is monitoring.  Relays.MonitoredObj(arg)  \u2013 Set the full name of the object this relay is monitoring.  Relays.SwitchedObj()  \u2013 Get the full name of element that will switched when relay trips.  Relays.SwitchedObj(arg)  \u2013 Set the full name of element that will switched when relay trips.  Relays.AllNames()  \u2013 Get a vector of strings containing names of all relay elements.", 
            "title": "Relays"
        }, 
        {
            "location": "/api/#sensors", 
            "text": "# OpenDSSDirect.DSS.Sensors     Module .   module Sensors  \u2013 Functions for interfacing with the active OpenDSS Sensor.  Sensors.Count()  \u2013 Get number of Sensors in active circuit.  Sensors.First()  \u2013 Set the first sensor active. Returns 0 if none.  Sensors.Next()  \u2013 Set the next sensor active. Returns 0 if none  Sensors.IsDelta()  \u2013 Returns 1 if the sensor is connected in delta; otherwise, returns 0.  Sensors.IsDelta(arg)  \u2013 Allows to set 1 if the sensor is connected in delta; otherwise, set 0 (argument).  Sensors.ReverseDelta()  \u2013 Returns 1 if voltage measurements are 1-3, 3-2, 2-1; otherwise 0.  Sensors.ReverseDelta(arg)  \u2013 Allows to set 1 if voltage measurements are 1-3, 3-2, 2-1; otherwise 0.  Sensors.MeteredTerminal()  \u2013 Get the number of the measured terminal in the measured element.  Sensors.MeteredTerminal(arg)  \u2013 Set the number of the measured terminal in the measured element.  Sensors.Reset()  \u2013 Clears the active sensor.  Sensors.ResetAll()  \u2013 Clears all Sensors in the active circuit.  Sensors.PctError()  \u2013 Get the assumed percent error in the Sensor measurement. Default is 1.  Sensors.PctError(arg)  \u2013 Set the assumed percent error in the Sensor measurement. Default is 1.  Sensors.Weight()  \u2013 Get the weighting factor for this sensor measurement with respect to the other Sensors. Default is 1.  Sensors.Weight(arg)  \u2013 Set the weighting factor for this sensor measurement with respect to the other Sensors. Default is 1.  Sensors.kVBase()  \u2013 Get the voltage base for the sensor measurements. LL for 2 and 3 - phase Sensors, LN for 1-phase Sensors.  Sensors.kVBase(arg)  \u2013 Set the voltage base for the sensor measurements. LL for 2 and 3 - phase Sensors, LN for 1-phase Sensors.  Sensors.Name()  \u2013 Get the name of the active sensor object.  Sensors.Name(arg)  \u2013 Set the name of the active sensor object.  Sensors.MeteredElement()  \u2013 Get the full name of the measured element.  Sensors.MeteredElement(arg)  \u2013 Set the full name of the measured element.  Sensors.AllNames()  \u2013 Returns a vector of sensor names.  Sensors.Currents()  \u2013 Get an array of doubles for the line current measurements; don't use with KWS and KVARS.  Sensors.kvar()  \u2013 Get an array of doubles for Q measurements; overwrites currents with a new estimate using KWS.  Sensors.kW()  \u2013 Get an array of doubles for P measurements; overwrites currents with a new estimate using KVARS.", 
            "title": "Sensors"
        }, 
        {
            "location": "/api/#settings", 
            "text": "# OpenDSSDirect.DSS.Settings     Module .   module Settings  \u2013 Functions for controlling global OpenDSS settings.  Settings.AllowDuplicates()  \u2013 Get if OpenDSS allows duplicate names of objects: {1 allow, 0 not allow}.  Settings.AllowDuplicates(arg)  \u2013 Set if OpenDSS allows duplicate names of objects: {1 allow, 0 not allow}.  Settings.ZoneLock()  \u2013 Get the status of Lock zones on energy Meters to prevent rebuilding if a circuit change occurs: {1= true, 0= False}.  Settings.ZoneLock(arg)  \u2013 Set the status of Lock zones on energy Meters to prevent rebuilding if a circuit change occurs: {1= true, 0= False}.  Settings.CktModel()  \u2013 Get {dssMultiphase* | dssPositiveSeq} Indicate if the circuit model is positive sequence.  Settings.CktModel(arg)  \u2013 Set {dssMultiphase* | dssPositiveSeq} Indicate if the circuit model is positive sequence.  Settings.Trapezoidal()  \u2013 Get {True (1) | False (0)} value of trapezoidal integration flag in Energy Meters.  Settings.Trapezoidal(arg)  \u2013 Set {True (1) | False (0)} value of trapezoidal integration flag in Energy Meters.  Settings.AllocationFactors(arg)  \u2013 Set all load allocation factors for all loads defined by XFKVA property to this value.  Settings.NormVminpu()  \u2013 Get the per unit minimum voltage for Normal conditions.  Settings.NormVminpu(arg)  \u2013 Set the per unit minimum voltage for Normal conditions.  Settings.NormVmaxpu()  \u2013 Get the per unit maximum voltage for Normal conditions.  Settings.NormVmaxpu(arg)  \u2013 Set the per unit maximum voltage for Normal conditions.  Settings.EmergVminpu()  \u2013 Get the per unit minimum voltage for Emergency conditions.  Settings.EmergVminpu(arg)  \u2013 Set the per unit minimum voltage for Emergency conditions.  Settings.EmergVmaxpu()  \u2013 Get the per unit maximum voltage for Emergency conditions.  Settings.EmergVmaxpu(arg)  \u2013 Set the per unit maximum voltage for Emergency conditions.  Settings.UEWeight()  \u2013 Get the weighting factor applied to UE register values.  Settings.UEWeight(arg)  \u2013 Set the weighting factor applied to UE register values.  Settings.LossWeight()  \u2013 Get the weighting factor applied to Loss register values.  Settings.LossWeight(arg)  \u2013 Set the weighting factor applied to Loss register values.  Settings.PriceSignal()  \u2013 Get the price signal for the circuit.  Settings.PriceSignal(arg)  \u2013 Set the price signal for the circuit.  Settings.AutoBusList()  \u2013 Get the list of Buses or (File=xxxxx) syntax for the AutoAdd solution mode.  Settings.AutoBusList(arg)  \u2013 Set the list of Buses or (File=xxxxx) syntax for the AutoAdd solution mode.  Settings.PriceCurve()  \u2013 Get the name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.  Settings.PriceCurve(arg)  \u2013 Set the name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.  Settings.UERegs()  \u2013 Get the array of Integers defining Energy Meter registers to use for computing UE.  Settings.LossRegs()  \u2013 Get the array of Integers defining Energy Meter registers to use for computing Losses.  Settings.VoltageBases()  \u2013 Get the array of doubles defining the legal voltage bases in kV L-L.", 
            "title": "Settings"
        }, 
        {
            "location": "/api/#solution", 
            "text": "# OpenDSSDirect.DSS.Solution     Module .   module Solution  \u2013 Functions for controlling OpenDSS solutions.  Solution.Solve()  \u2013 Executes the solution for the present solution mode. Returns 0.  Solution.Mode()  \u2013 The present solution mode (See DSS help).  Solution.Mode(arg)  \u2013 Modifies the present solution mode (See DSS help).  Solution.Hour()  \u2013 The present hour (See DSS help).  Solution.Hour(arg)  \u2013 Modifies the present hour (See DSS help).  Solution.Year()  \u2013 The present Year (See DSS help).  Solution.Year(arg)  \u2013 Modifies the present Year (See DSS help).  Solution.Iterations()  \u2013 Return the number of iterations taken for the last solution.  Solution.MaxIterations()  \u2013 The Maximum number of iterations used to solve the circuit.  Solution.MaxIterations(arg)  \u2013 Modifies the Maximum number of iterations used to solve the circuit.  Solution.Number()  \u2013 The number of solutions to perform for MonteCarlo and time series simulations.  Solution.Number(arg)  \u2013 Modifies the number of solutions to perform for MonteCarlo and time series simulations.  Solution.Random()  \u2013 \"The randomization mode for random variables \" * (@Gaussian_str(\" o \",\"Uniform\") * \".\")  Solution.Random(arg)  \u2013 \"Modifies the randomization mode for random variables \" * (@Gaussian_str(\" o \",\"Uniform\") * \".\")  Solution.LoadModel()  \u2013 The Load Model: {dssPowerFlow (default)|dssAdmittance}.  Solution.LoadModel(arg)  \u2013 Modifies the Load Model: {dssPowerFlow (default)|dssAdmittance}.  Solution.AddType()  \u2013 The type of device to add in AutoAdd Mode: {dssGen (default)|dssCap}.  Solution.AddType(arg)  \u2013 Modifies the type of device to add in AutoAdd Mode: {dssGen (default)|dssCap}.  Solution.Algorithm()  \u2013 The base solution algorithm: {dssNormalSolve | dssNewtonSolve}.  Solution.Algorithm(arg)  \u2013 Modifies the base solution algorithm: {dssNormalSolve | dssNewtonSolve}.  Solution.ControlMode()  \u2013 The mode for control devices: {dssStatic (default) | dssEvent | dssTime}.  Solution.ControlMode(arg)  \u2013 Modifies the mode for control devices: {dssStatic (default) | dssEvent | dssTime}.  Solution.ControlIterations()  \u2013 The current value of the control iteration counter.  Solution.ControlIterations(arg)  \u2013 Modifies the current value of the control iteration counter.  Solution.MaxControlIterations()  \u2013 The maximum allowable control iterations.  Solution.MaxControlIterations(arg)  \u2013 Modifies the maximum allowable control iterations.  Solution.SampleDoControlActions()  \u2013 Sample controls and then process the control queue for present control mode and dispatch control actions. Returns 0.  Solution.CheckFaultStatus()  \u2013 Executes status check on all fault objects defined in the circuit. Returns 0.  Solution.SolveDirect()  \u2013 Executes a direct solution from the system Y matrix, ignoring compensation currents of loads, generators (includes Yprim only).  Solution.SolvePFlow()  \u2013 Solves using present power flow method. Iterative solution rather than direct solution.  Solution.SolveNoControl()  \u2013 Is similar to SolveSnap except no control actions are checked or executed.  Solution.SolvePlusControl()  \u2013 Executes a power flow solution (SolveNoControl) plus executes a CheckControlActions that executes any pending control actions.  Solution.InitSnap()  \u2013 Initializes some variables for snap shot power flow. SolveSnap does this automatically.  Solution.CheckControls()  \u2013 Performs the normal process for sampling and executing Control Actions and Fault Status and rebuilds Y if necessary.  Solution.SampleControlDevices()  \u2013 Executes a sampling of all intrinsic control devices, which push control actions into the control queue.  Solution.DoControlActions()  \u2013 Pops control actions off the control queue and dispatches to the proper control element.  Solution.BuildYMatrix()  \u2013 Forces building of the System Y matrix according to the argument: {1= series elements only | 2= Whole Y matrix}.  Solution.SystemYChanged()  \u2013 Indicates if elements of the System Y have been changed by recent activity. If changed returns 1; otherwise 0.  Solution.Converged()  \u2013 Indicates whether the circuit solution converged (1 converged | 0 not converged).  Solution.Converged(arg)  \u2013 Modifies the converged flag (1 converged | 0 not converged).  Solution.TotalIterations()  \u2013 The total iterations including control iterations for most recent solution.  Solution.MostIterationsDone()  \u2013 The max number of iterations required to converge at any control iteration of the most recent solution.  Solution.ControlActionsDone()  \u2013 Indicates that the control actions are done: {1 done, 0 not done}.  Solution.ControlActionsDone(arg)  \u2013 Modifies the flag to indicate that the control actions are done: {1 done, 0 not done}.  Solution.FinishTimeStep()  \u2013 Call cleanup, sample Monitors, and increment time at end of time step.  Solution.Cleanup()  \u2013 Update storage, invcontrol, etc., at end of time step.  Solution.Frequency()  \u2013 The frequency for the next solution.  Solution.Frequency(arg)  \u2013 Set the frequency for the next solution.  Solution.Seconds()  \u2013 The seconds from top of the hour.  Solution.Seconds(arg)  \u2013 Set the seconds from top of the hour.  Solution.StepSize()  \u2013 The step size for the next solution.  Solution.StepSize(arg)  \u2013 Set the step size for the next solution.  Solution.LoadMult()  \u2013 The default load multiplier applied to all non-fixed loads.  Solution.LoadMult(arg)  \u2013 Set the default load multiplier applied to all non-fixed loads.  Solution.Convergence()  \u2013 The solution convergence tolerance.  Solution.Convergence(arg)  \u2013 Set the solution convergence tolerance.  Solution.PctGrowth()  \u2013 The percent default annual load growth rate.  Solution.PctGrowth(arg)  \u2013 Set the percent default annual load growth rate.  Solution.GenkW()  \u2013 The generator kW for AutoAdd mode.  Solution.GenkW(arg)  \u2013 Set the generator kW for AutoAdd mode.  Solution.GenPF()  \u2013 The pf for generators in AutoAdd mode.  Solution.GenPF(arg)  \u2013 Set the pf for generators in AutoAdd mode.  Solution.Capkvar()  \u2013 The capacitor kvar for adding in AutoAdd mode.  Solution.Capkvar(arg)  \u2013 Set the capacitor kvar for adding in AutoAdd mode.  Solution.GenMult()  \u2013 The default multiplier applied to generators (like LoadMult).  Solution.GenMult(arg)  \u2013 Set the default multiplier applied to generators (like LoadMult).  Solution.DblHour()  \u2013 The hour as a double, including fractional part.  Solution.DblHour(arg)  \u2013 Set the hour as a double, including fractional part.  Solution.StepSizeMin()  \u2013 Set the step size in minutes.  Solution.StepSizeHr()  \u2013 Set the step size in Hours.  Solution.ModeID()  \u2013 The ID (text) of the present solution mode.  Solution.LDCurve()  \u2013 The Load-Duration Curve name for LD modes.  Solution.LDCurve(arg)  \u2013 Set the Load-Duration Curve name for LD modes.  Solution.DefaultDaily()  \u2013 \"The default daily load shape (defaults to \" * @Default_str(\").\")  Solution.DefaultDaily(arg)  \u2013 \"Set the default daily load shape (defaults to \" * @Default_str(\").\")  Solution.DefaultYearly()  \u2013 \"The default yearly load shape (defaults to \" * @Default_str(\").\")  Solution.DefaultYearly(arg)  \u2013 \"Set the default yearly load shape (defaults to \" * @Default_str(\").\")  Solution.EventLog()  \u2013 Returns an array of strings containing the Event Log.", 
            "title": "Solution"
        }, 
        {
            "location": "/api/#swtcontrols", 
            "text": "# OpenDSSDirect.DSS.SwtControls     Module .   module SwtControls  \u2013 Functions for interfacing with the active OpenDSS SwtControl.  SwtControls.First()  \u2013 Set the first SwtControl active. Returns 0 if no more.  SwtControls.Next()  \u2013 Set the next SwtControl active. Returns 0 if no more.  SwtControls.Action()  \u2013 Get the open (1) or close (2) action of the switch. No effect if switch is locked. However, reset removes any lock and then closes the switch (shelf state). 0 = none action.  SwtControls.Action(arg)  \u2013 Set open (1) or close (2) the switch. No effect if switch is locked. However, reset removes any lock and then closes the switch (shelf state). 0 = none action (see manual for details).  SwtControls.IsLocked()  \u2013 Get the lock state: {1 locked | 0 not locked}.  SwtControls.IsLocked(arg)  \u2013 Set the lock to prevent both manual and automatic switch operation.  SwtControls.SwitchedTerm()  \u2013 Get the terminal number where the switch is located on the SwitchedObj.  SwtControls.SwitchedTerm(arg)  \u2013 Set the terminal number where the switch is located on the SwitchedObj.  SwtControls.Count()  \u2013 Get the total number of SwtControls in the active circuit.  SwtControls.Delay()  \u2013 Get the time delay [s] between arming and opening or closing the switch. Control may reset before actually operating the switch.  SwtControls.Delay(arg)  \u2013 Set the time delay [s] between arming and opening or closing the switch. Control may reset before actually operating the switch.  SwtControls.Name()  \u2013 Get the name of the active SwtControl.  SwtControls.Name(arg)  \u2013 Set a SwtControl active by name.  SwtControls.SwitchedObj()  \u2013 Get the name of the switched object by the active SwtControl.  SwtControls.SwitchedObj(arg)  \u2013 Set the switched object by name.  SwtControls.AllNames()  \u2013 Get a vector of strings with all SwtControl names in the active circuit.", 
            "title": "SwtControls"
        }, 
        {
            "location": "/api/#topology", 
            "text": "# OpenDSSDirect.DSS.Topology     Module .   module Topology  \u2013 Functions for interfacing with the active OpenDSS Topology.  Topology.NumLoops()  \u2013 Get the number of loops.  Topology.NumIsolatedBranches()  \u2013 Get the number of isolated branches (PD elements and capacitors).  Topology.NumIsolatedLoads()  \u2013 Get the number of isolated loads.  Topology.First()  \u2013 Set the first branch active, returns 0 if none.  Topology.Next()  \u2013 Set the next branch active, returns 0 if none.  Topology.ActiveBranch()  \u2013 The index of the active Branch.  Topology.ForwardBranch()  \u2013 Move forward in the tree, return index of new active branch or 0 if no more.  Topology.BackwardBranch()  \u2013 Move back toward the source, return index of new active branch or 0 if no more.  Topology.LoopedBranch()  \u2013 Move to looped branch, return index or 0 if none.  Topology.ParallelBranch()  \u2013 Mode to directly parallel branch, return index or 0 if none.  Topology.FirstLoad()  \u2013 Set as active load the first load at the active branch, return index or 0 if none.  Topology.NextLoad()  \u2013 Set as active load the next load at the active branch, return index or 0 if none.  Topology.ActiveLevel()  \u2013 Get the topological depth of the active branch.  Topology.BranchName()  \u2013 Get the name of the active branch.  Topology.BranchName(arg)  \u2013 Set the name of the active branch.  Topology.BusName()  \u2013 Get the name of the active Bus.  Topology.BusName(arg)  \u2013 Set the Bus active by name.  Topology.AllLoopedPairs()  \u2013 Get a vector of all looped element names, by pairs.  Topology.AllIsolatedBranches()  \u2013 Get a vector of all isolated branch names.  Topology.AllIsolatedLoads()  \u2013 Get a vector of all isolated load names.", 
            "title": "Topology"
        }, 
        {
            "location": "/api/#transformers", 
            "text": "# OpenDSSDirect.DSS.Transformers     Module .   module Transformers  \u2013 Functions for interfacing with the active OpenDSS transformer.  Transformers.NumWindings()  \u2013 Get the number of windings on this transformer. Allocates memory; set or change this property first.  Transformers.NumWindings(arg)  \u2013 Set the number of windings on this transformer. Allocates memory; set or change this property first.  Transformers.Wdg()  \u2013 Get the active winding number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.).  Transformers.Wdg(arg)  \u2013 Set the active winding number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.).  Transformers.NumTaps()  \u2013 Get the active winding number of tap steps between MinTap and MaxTap.  Transformers.NumTaps(arg)  \u2013 Set the active winding number of tap steps between MinTap and MaxTap  Transformers.IsDelta()  \u2013 Get the information about if the active winding is delta (1) or wye (0) connection.  Transformers.IsDelta(arg)  \u2013 Set the information about if the active winding is delta (1) or wye (0) connection.  Transformers.First()  \u2013 Set the first Transformer active. Return 0 if no more.  Transformers.Next()  \u2013 Set the next Transformer active. Return 0 if no more.  Transformers.Count()  \u2013 Get the number of Transformers within the active circuit.  Transformers.R()  \u2013 Get the active winding resistance in %.  Transformers.R(arg)  \u2013 Set the active winding resistance in %.  Transformers.Tap()  \u2013 Get the active winding tap in per-unit.  Transformers.Tap(arg)  \u2013 Set the active winding tap in per-unit.  Transformers.MinTap()  \u2013 Get the active winding minimum tap in per-unit.  Transformers.MinTap(arg)  \u2013 Set the active winding minimum tap in per-unit.  Transformers.MaxTap()  \u2013 Get the active winding maximum tap in per-unit.  Transformers.MaxTap(arg)  \u2013 Set the active winding maximum tap in per-unit.  Transformers.kV()  \u2013 Get the active winding kV rating. Phase-phase for 2 or 3 phases, actual winding kV 1 phase transformer.  Transformers.kV(arg)  \u2013 Set the active winding kV rating. Phase-phase for 2 or 3 phases, actual winding kV 1 phase transformer.  Transformers.kVA()  \u2013 Get the active winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.  Transformers.kVA(arg)  \u2013 Set the active winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.  Transformers.Xneut()  \u2013 Get the active winding neutral reactance [ohms] for wye connections.  Transformers.Xneut(arg)  \u2013 Set the active winding neutral reactance [ohms] for wye connections.  Transformers.Rneut()  \u2013 Get the active winding neutral resistance [ohms] for wye connections. Set less than zero ungrounded wye.  Transformers.Rneut(arg)  \u2013 Set the active winding neutral resistance [ohms] for wye connections. Set less than zero ungrounded wye.  Transformers.Xhl()  \u2013 Get the percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2 winding or 3 winding Transformers.  Transformers.Xhl(arg)  \u2013 Set the percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2 winding or 3 winding Transformers.  Transformers.Xht()  \u2013 Get the percent reactance between windings 1 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.  Transformers.Xht(arg)  \u2013 Set the percent reactance between windings 1 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.  Transformers.Xlt()  \u2013 Get the percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.  Transformers.Xlt(arg)  \u2013 Set the percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3 winding Transformers only.  Transformers.XfmrCode()  \u2013 Get the name of an XfrmCode that supplies electrical paraMeters for this transformer.  Transformers.XfmrCode(arg)  \u2013 Set the name of an XfrmCode that supplies electrical paraMeters for this transformer.  Transformers.Name()  \u2013 Get the active transformer name and 3, on winding_1_kVA base. Use for 3 winding transformer only.  Transformers.Name(arg)  \u2013 Set the active transformer name and 3, on winding_1_kVA base. Use for 3 winding transformer only.  Transformers.AllNames()  \u2013 Get a vector of strings with all Transformer names in the active circuit.", 
            "title": "Transformers"
        }, 
        {
            "location": "/api/#vsources", 
            "text": "# OpenDSSDirect.DSS.Vsources     Module .   module Vsources  \u2013 Functions for interfacing with the active OpenDSS voltage source.  Vsources.Count()  \u2013 The number of VSource objects currently defined in the active circuit.  Vsources.First()  \u2013 Set the first VSource to be active; returns 0 if none.  Vsources.Next()  \u2013 Set the next VSource to be active; returns 0 if none.  Vsources.Phases()  \u2013 Get the number of phases of the active VSource.  Vsources.Phases(arg)  \u2013 Set the number of phases of the active VSource.  Vsources.BasekV()  \u2013 Get the source voltage in kV.  Vsources.BasekV(arg)  \u2013 Set the source voltage in kV.  Vsources.PU()  \u2013 Get the source voltage in pu.  Vsources.PU(arg)  \u2013 Set the source voltage in pu.  Vsources.AngleDeg()  \u2013 Get the source phase angle of first phase in degrees.  Vsources.AngleDeg(arg)  \u2013 Set the source phase angle of first phase in degrees.  Vsources.Frequency()  \u2013 Get the source frequency in Hz.  Vsources.Frequency(arg)  \u2013 Set the source frequency in Hz.  Vsources.Name()  \u2013 Get the name of the active VSource.  Vsources.Name(arg)  \u2013 Set the name of the active VSource.  Vsources.AllNames()  \u2013 Get the names of all Vsources", 
            "title": "Vsources"
        }, 
        {
            "location": "/api/#xycurves", 
            "text": "# OpenDSSDirect.DSS.XYCurves     Module .   module XYCurves  \u2013 Functions for interfacing with the active OpenDSS XYCurve.  XYCurves.Count()  \u2013 Get number of XYCurves in active circuit.  XYCurves.First()  \u2013 Set first XYCurves object active; returns 0 if none.  XYCurves.Next()  \u2013 Set next XYCurves object active; returns 0 if none.  XYCurves.Npts()  \u2013 Get the number of points in X-Y curve.  XYCurves.Npts(arg)  \u2013 Set the number of points in X-Y curve.  XYCurves.X()  \u2013 Get the interpolated value after setting Y.  XYCurves.X(arg)  \u2013 Set the X value.  XYCurves.Y()  \u2013 Get the interpolated value after setting X.  XYCurves.Y(arg)  \u2013 Set the Y value.  XYCurves.XShift()  \u2013 Get the amount to shift X value from original curve.  XYCurves.XShift(arg)  \u2013 Set the amount to shift X value from original curve.  XYCurves.YShift()  \u2013 Get the amount to shift Y value from original curve.  XYCurves.YShift(arg)  \u2013 Set the amount to shift Y value from original curve.  XYCurves.XScale()  \u2013 Get the factor to scale X values from original curve.  XYCurves.XScale(arg)  \u2013 Set the factor to scale X values from original curve.  XYCurves.YScale()  \u2013 Get the factor to scale Y values from original curve.  XYCurves.YScale(arg)  \u2013 Set the factor to scale Y values from original curve.  XYCurves.Name()  \u2013 Get the name of the active XYCurve Object.  XYCurves.Name(arg)  \u2013 Set the name of the active XYCurve Object.  XYCurves.XArray()  \u2013 Get the X values as a vector of doubles. Set Npts to max number expected if setting.  XYCurves.YArray()  \u2013 Get the Y values as a vector of doubles. Set Npts to max number expected if setting.", 
            "title": "XYCurves"
        }, 
        {
            "location": "/flags/", 
            "text": "Flag objects\n\n\nSeveral flag variables are also defined, each with multiple entries defined. \n\n\nHere is an example of use of \nCapControlModes.KVAR\n: \n\n\nCapControls\n.\nMode\n(\nCapControlModes\n.\nKVAR\n)\n\n\n\n\n\n\n\n\nActionCodes\n\n\nCapControlModes\n\n\nLineUnits\n\n\nLoadModels\n\n\nLoadStatus\n\n\nMonitorModes\n\n\nOptions\n\n\nSolveModes\n\n\n\n\n...\n\n\n#\nOpenDSSDirect.DSS.ActionCodes\n \n \nModule\n.\n\n\n\n\nActionCodes flags - options include:\n\n\n\n\nNone\n :\u00a0\u00a0No\u00a0action\n\n\nOpen\n :\u00a0\u00a0Open\u00a0a\u00a0switch\n\n\nClose\n :\u00a0\u00a0Close\u00a0a\u00a0switch\n\n\nReset\n :\u00a0\u00a0Reset\u00a0to\u00a0the\u00a0shelf\u00a0state\u00a0(unlocked,\u00a0closed\u00a0for\u00a0a\u00a0switch\n\n\nLock\n :\u00a0\u00a0Lock\u00a0a\u00a0switch,\u00a0prventing\u00a0both\u00a0manual\u00a0and\u00a0automatic\u00a0operation\n\n\nUnlock\n :\u00a0\u00a0Unlock\u00a0a\u00a0switch,\u00a0permitting\u00a0both\u00a0manual\u00a0and\u00a0automatic\u00a0operation\n\n\nTapUp\n :\u00a0\u00a0Move\u00a0a\u00a0regulator\u00a0tap\u00a0up\n\n\nTapDown\n :\u00a0Move\u00a0a\u00a0regulator\u00a0tap\u00a0down\n\n\n\n\n#\nOpenDSSDirect.DSS.CapControlModes\n \n \nModule\n.\n\n\n\n\nCapControlModes flags - options include:\n\n\n\n\nCurrent\n : Current\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0CT\u00a0secondary\n\n\nVoltage\n : Voltage\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0the\u00a0PT\u00a0secondary\u00a0base\n\n\nKVAR\n : kvar\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0PT\u00a0/\u00a0CT\u00a0base\n\n\nTime\n : Time\u00a0control ON\u00a0and\u00a0OFF\u00a0settings\u00a0are\u00a0seconds\u00a0from\u00a0midnight\n\n\nPF\n : ON\u00a0and\u00a0OFF\u00a0settings\u00a0are\u00a0power\u00a0factor,\u00a0negative\u00a0for\u00a0leading\n\n\n\n\nExample: \n\n\ncapcontrols.Mode(CapControlModes.KVAR)\n\n\n\n\n\n#\nOpenDSSDirect.DSS.LineUnits\n \n \nModule\n.\n\n\n\n\nLineUnits flags - options include:\n\n\n\n\nNone\n :\u00a0\u00a0No\u00a0line\u00a0length\u00a0unit.\n\n\nMiles\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0in\u00a0miles.\n\n\nkFt\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0in\u00a0thousand\u00a0feet.\n\n\nkm\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0km.\n\n\nmeter\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0Meters.\n\n\nft\n :\u00a0\u00a0Line\u00a0units\u00a0in\u00a0feet.\n\n\ninch\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0inches.\n\n\ncm\n :\u00a0\u00a0Line\u00a0units\u00a0are\u00a0cm.\n\n\nmm\n :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0mm.\n\n\nMaxnum\n :\u00a0Maximum\u00a0number\u00a0of\u00a0line\u00a0units\u00a0constants.\n\n\n\n\n#\nOpenDSSDirect.DSS.LoadModels\n \n \nModule\n.\n\n\n\n\nLoadModels flags - options include:\n\n\n\n\nConstPQ\n\n\nConstZ\n\n\nMotor\n\n\nCVR\n\n\nConstI\n\n\nConstPFixedQ\n\n\nConstPFixedX\n\n\nZIPV\n\n\n\n\n#\nOpenDSSDirect.DSS.LoadStatus\n \n \nModule\n.\n\n\n\n\nLoadStatus flags - options include:\n\n\n\n\nVariable\n\n\nFixed\n\n\nExempt\n\n\n\n\n#\nOpenDSSDirect.DSS.Options\n \n \nModule\n.\n\n\n\n\nOptions flags - options include:\n\n\n\n\nPowerFlow\n :\u00a0\u00a0Power\u00a0Flow\u00a0load\u00a0model\u00a0option\n\n\nAdmittance\n :\u00a0\u00a0Admittance\u00a0load\u00a0model\u00a0option\n\n\nNormalSolve\n :\u00a0\u00a0Solution\u00a0algorithm\u00a0option\u00a0\u2010\u00a0Normal\u00a0solution\u00a0mode\n\n\nNewtonSolve\n :\u00a0\u00a0Solution\u00a0algorithm\u00a0option\u00a0\u2010\u00a0Newton\u00a0solution\n\n\nStatic\n :\u00a0\u00a0Control\u00a0Mode\u00a0option\u00a0\u2010\u00a0Static\n\n\nEvent\n :\u00a0\u00a0Control\u00a0Mode\u00a0Option\u00a0\u2010\u00a0Event\u00a0driven\u00a0solution\u00a0mode\n\n\nTime\n :\u00a0\u00a0Control\u00a0mode\u00a0option\u00a0\u2010\u00a0Time\u00a0driven\u00a0mode\n\n\nMultiphase\n :\u00a0\u00a0Circuit\u00a0model\u00a0is\u00a0multiphase\u00a0(default)\n\n\nPositiveSeq\n :\u00a0\u00a0Circuit\u00a0model\u00a0is\u00a0positive\u00a0sequence\u00a0model\u00a0only\n\n\nGaussian\n :\u00a0\u00a0Random\u00a0mode\u00a0=\u00a0Gaussian\n\n\nUniform\n :\u00a0\u00a0Random\u00a0mode\u00a0=\u00a0Uniform\n\n\nLogNormal\n :\u00a0\u00a0Random\u00a0Mode\u00a0=\u00a0Log\u00a0normal\n\n\nAddGen\n :\u00a0\u00a0Add\u00a0generators\u00a0in\u00a0AutoAdd\u00a0mode\n\n\nAddCap\n :\u00a0\u00a0Add\u00a0capacitors\u00a0in\u00a0AutoAdd\u00a0mode\n\n\nControlOFF\n :\u00a0\u00a0Control\u00a0Mode\u00a0OFF\u00a0=\u00a0\u20101\n\n\n\n\n#\nOpenDSSDirect.DSS.MonitorModes\n \n \nModule\n.\n\n\n\n\nMonitorModes flags - options include:\n\n\n\n\nVI\n : Monitor\u00a0records\u00a0Voltage\u00a0and\u00a0Current\u00a0at\u00a0the\u00a0terminal\u00a0(Default)\n\n\nPower\n : Monitor\u00a0records\u00a0kW,\u00a0kvar\u00a0or\u00a0kVA,\u00a0angle\u00a0values,\u00a0etc.\u00a0at\u00a0the\u00a0terminal\u00a0to\u00a0which\u00a0it\u00a0is connected\n\n\nTaps\n : For\u00a0monitoring\u00a0Regulator\u00a0and\u00a0Transformer\u00a0taps\n\n\nStates\n : For\u00a0monitoring\u00a0State\u00a0Variables\u00a0(for\u00a0PC\u00a0Elements\u00a0only)\n\n\nSequence\n : Reports\u00a0the\u00a0monitored\u00a0quantities\u00a0as\u00a0sequence\u00a0quantities\n\n\nMagnitude\n : Reports\u00a0the\u00a0monitored\u00a0quantities\u00a0in\u00a0Magnitude\u00a0Only\n\n\nPosOnly\n : Reports\u00a0the\u00a0Positive\u00a0Seq\u00a0only\u00a0or\u00a0avg\u00a0of\u00a0all\u00a0phases\n\n\n\n\nSequence\n, \nMagnitude\n, and \nPosOnly\n are bit-level flags that can be combined with other flags. It's best to use \n to test for one of these flags. Use \n|\n to  combine flags.\n\n\nExamples: \n\n\nMonitors.Mode() \n MonitorModes.Power\nMonitors.Mode(MonitorModes.Magnitude | MonitorModes.Power)\n\n\n\n\n\n#\nOpenDSSDirect.DSS.SolveModes\n \n \nModule\n.\n\n\n\n\nSolveModes flags - options include:\n\n\n\n\nSnapShot\n :\u00a0Solve\u00a0a\u00a0single\u00a0snapshot\u00a0power\u00a0flow\n\n\nDutyCycle\n :\u00a0Solve\u00a0following\u00a0Duty\u00a0Cycle\u00a0load\u00a0shapes\n\n\nDirect\n :\u00a0Solve\u00a0direct\u00a0(forced\u00a0admittance\u00a0model\n\n\nDaily\n :\u00a0Solve\u00a0following\u00a0Daily\u00a0load\u00a0shapes\n\n\nMonte1\n :\u00a0Monte\u00a0Carlo\u00a0Mode\u00a01\n\n\nMonte2\n :\u00a0\u00a0Monte\u00a0Carlo\u00a0Mode\u00a02\n\n\nMonte3\n :\u00a0\u00a0Monte\u00a0Carlo\u00a0Mode\u00a03\n\n\nFaultStudy\n :\u00a0Fault\u00a0study\u00a0at\u00a0all\u00a0buses\n\n\nYearly\n :\u00a0Solve\u00a0following\u00a0Yearly\u00a0load\u00a0shapes\n\n\nMonteFault\n :\u00a0Monte\u00a0carlo\u00a0Fault\u00a0Study\n\n\nPeakDay\n :\u00a0Solves\u00a0for\u00a0Peak\u00a0Day\u00a0using\u00a0Daily\u00a0load\u00a0curve\n\n\nLD1\n :\u00a0Load\u2010duration\u00a0Mode\u00a01\n\n\nLD2\n :\u00a0\u00a0Load\u2010Duration\u00a0Mode\u00a02\n\n\nAutoAdd\n :\u00a0\u00a0Auto\u00a0add\u00a0generators\u00a0or\u00a0capacitors\n\n\nHarmonic\n :\u00a0\u00a0\u00a0(no\u00a0Help\u00a0string\u00a0available)\n\n\nDynamic", 
            "title": "Flag objects"
        }, 
        {
            "location": "/flags/#flag-objects", 
            "text": "Several flag variables are also defined, each with multiple entries defined.   Here is an example of use of  CapControlModes.KVAR :   CapControls . Mode ( CapControlModes . KVAR )    ActionCodes  CapControlModes  LineUnits  LoadModels  LoadStatus  MonitorModes  Options  SolveModes   ...  # OpenDSSDirect.DSS.ActionCodes     Module .   ActionCodes flags - options include:   None  :\u00a0\u00a0No\u00a0action  Open  :\u00a0\u00a0Open\u00a0a\u00a0switch  Close  :\u00a0\u00a0Close\u00a0a\u00a0switch  Reset  :\u00a0\u00a0Reset\u00a0to\u00a0the\u00a0shelf\u00a0state\u00a0(unlocked,\u00a0closed\u00a0for\u00a0a\u00a0switch  Lock  :\u00a0\u00a0Lock\u00a0a\u00a0switch,\u00a0prventing\u00a0both\u00a0manual\u00a0and\u00a0automatic\u00a0operation  Unlock  :\u00a0\u00a0Unlock\u00a0a\u00a0switch,\u00a0permitting\u00a0both\u00a0manual\u00a0and\u00a0automatic\u00a0operation  TapUp  :\u00a0\u00a0Move\u00a0a\u00a0regulator\u00a0tap\u00a0up  TapDown  :\u00a0Move\u00a0a\u00a0regulator\u00a0tap\u00a0down   # OpenDSSDirect.DSS.CapControlModes     Module .   CapControlModes flags - options include:   Current  : Current\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0CT\u00a0secondary  Voltage  : Voltage\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0the\u00a0PT\u00a0secondary\u00a0base  KVAR  : kvar\u00a0control,\u00a0ON\u00a0and\u00a0OFF\u00a0settings\u00a0on\u00a0PT\u00a0/\u00a0CT\u00a0base  Time  : Time\u00a0control ON\u00a0and\u00a0OFF\u00a0settings\u00a0are\u00a0seconds\u00a0from\u00a0midnight  PF  : ON\u00a0and\u00a0OFF\u00a0settings\u00a0are\u00a0power\u00a0factor,\u00a0negative\u00a0for\u00a0leading   Example:   capcontrols.Mode(CapControlModes.KVAR)  # OpenDSSDirect.DSS.LineUnits     Module .   LineUnits flags - options include:   None  :\u00a0\u00a0No\u00a0line\u00a0length\u00a0unit.  Miles  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0in\u00a0miles.  kFt  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0in\u00a0thousand\u00a0feet.  km  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0km.  meter  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0Meters.  ft  :\u00a0\u00a0Line\u00a0units\u00a0in\u00a0feet.  inch  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0inches.  cm  :\u00a0\u00a0Line\u00a0units\u00a0are\u00a0cm.  mm  :\u00a0\u00a0Line\u00a0length\u00a0units\u00a0are\u00a0mm.  Maxnum  :\u00a0Maximum\u00a0number\u00a0of\u00a0line\u00a0units\u00a0constants.   # OpenDSSDirect.DSS.LoadModels     Module .   LoadModels flags - options include:   ConstPQ  ConstZ  Motor  CVR  ConstI  ConstPFixedQ  ConstPFixedX  ZIPV   # OpenDSSDirect.DSS.LoadStatus     Module .   LoadStatus flags - options include:   Variable  Fixed  Exempt   # OpenDSSDirect.DSS.Options     Module .   Options flags - options include:   PowerFlow  :\u00a0\u00a0Power\u00a0Flow\u00a0load\u00a0model\u00a0option  Admittance  :\u00a0\u00a0Admittance\u00a0load\u00a0model\u00a0option  NormalSolve  :\u00a0\u00a0Solution\u00a0algorithm\u00a0option\u00a0\u2010\u00a0Normal\u00a0solution\u00a0mode  NewtonSolve  :\u00a0\u00a0Solution\u00a0algorithm\u00a0option\u00a0\u2010\u00a0Newton\u00a0solution  Static  :\u00a0\u00a0Control\u00a0Mode\u00a0option\u00a0\u2010\u00a0Static  Event  :\u00a0\u00a0Control\u00a0Mode\u00a0Option\u00a0\u2010\u00a0Event\u00a0driven\u00a0solution\u00a0mode  Time  :\u00a0\u00a0Control\u00a0mode\u00a0option\u00a0\u2010\u00a0Time\u00a0driven\u00a0mode  Multiphase  :\u00a0\u00a0Circuit\u00a0model\u00a0is\u00a0multiphase\u00a0(default)  PositiveSeq  :\u00a0\u00a0Circuit\u00a0model\u00a0is\u00a0positive\u00a0sequence\u00a0model\u00a0only  Gaussian  :\u00a0\u00a0Random\u00a0mode\u00a0=\u00a0Gaussian  Uniform  :\u00a0\u00a0Random\u00a0mode\u00a0=\u00a0Uniform  LogNormal  :\u00a0\u00a0Random\u00a0Mode\u00a0=\u00a0Log\u00a0normal  AddGen  :\u00a0\u00a0Add\u00a0generators\u00a0in\u00a0AutoAdd\u00a0mode  AddCap  :\u00a0\u00a0Add\u00a0capacitors\u00a0in\u00a0AutoAdd\u00a0mode  ControlOFF  :\u00a0\u00a0Control\u00a0Mode\u00a0OFF\u00a0=\u00a0\u20101   # OpenDSSDirect.DSS.MonitorModes     Module .   MonitorModes flags - options include:   VI  : Monitor\u00a0records\u00a0Voltage\u00a0and\u00a0Current\u00a0at\u00a0the\u00a0terminal\u00a0(Default)  Power  : Monitor\u00a0records\u00a0kW,\u00a0kvar\u00a0or\u00a0kVA,\u00a0angle\u00a0values,\u00a0etc.\u00a0at\u00a0the\u00a0terminal\u00a0to\u00a0which\u00a0it\u00a0is connected  Taps  : For\u00a0monitoring\u00a0Regulator\u00a0and\u00a0Transformer\u00a0taps  States  : For\u00a0monitoring\u00a0State\u00a0Variables\u00a0(for\u00a0PC\u00a0Elements\u00a0only)  Sequence  : Reports\u00a0the\u00a0monitored\u00a0quantities\u00a0as\u00a0sequence\u00a0quantities  Magnitude  : Reports\u00a0the\u00a0monitored\u00a0quantities\u00a0in\u00a0Magnitude\u00a0Only  PosOnly  : Reports\u00a0the\u00a0Positive\u00a0Seq\u00a0only\u00a0or\u00a0avg\u00a0of\u00a0all\u00a0phases   Sequence ,  Magnitude , and  PosOnly  are bit-level flags that can be combined with other flags. It's best to use   to test for one of these flags. Use  |  to  combine flags.  Examples:   Monitors.Mode()   MonitorModes.Power\nMonitors.Mode(MonitorModes.Magnitude | MonitorModes.Power)  # OpenDSSDirect.DSS.SolveModes     Module .   SolveModes flags - options include:   SnapShot  :\u00a0Solve\u00a0a\u00a0single\u00a0snapshot\u00a0power\u00a0flow  DutyCycle  :\u00a0Solve\u00a0following\u00a0Duty\u00a0Cycle\u00a0load\u00a0shapes  Direct  :\u00a0Solve\u00a0direct\u00a0(forced\u00a0admittance\u00a0model  Daily  :\u00a0Solve\u00a0following\u00a0Daily\u00a0load\u00a0shapes  Monte1  :\u00a0Monte\u00a0Carlo\u00a0Mode\u00a01  Monte2  :\u00a0\u00a0Monte\u00a0Carlo\u00a0Mode\u00a02  Monte3  :\u00a0\u00a0Monte\u00a0Carlo\u00a0Mode\u00a03  FaultStudy  :\u00a0Fault\u00a0study\u00a0at\u00a0all\u00a0buses  Yearly  :\u00a0Solve\u00a0following\u00a0Yearly\u00a0load\u00a0shapes  MonteFault  :\u00a0Monte\u00a0carlo\u00a0Fault\u00a0Study  PeakDay  :\u00a0Solves\u00a0for\u00a0Peak\u00a0Day\u00a0using\u00a0Daily\u00a0load\u00a0curve  LD1  :\u00a0Load\u2010duration\u00a0Mode\u00a01  LD2  :\u00a0\u00a0Load\u2010Duration\u00a0Mode\u00a02  AutoAdd  :\u00a0\u00a0Auto\u00a0add\u00a0generators\u00a0or\u00a0capacitors  Harmonic  :\u00a0\u00a0\u00a0(no\u00a0Help\u00a0string\u00a0available)  Dynamic", 
            "title": "Flag objects"
        }, 
        {
            "location": "/dssmode/", 
            "text": "DSS REPL Mode\n\n\nOpenDSSDirect also includes a custom REPL mode for entering OpenDSS commands directly. This is similar to the Help (\n?\n) and Shell (\n;\n) modes. Use the right square bracket (\n]\n) to enter DSS mode. Hit backspace on a blank line to exit. Here is an example:\n\n\njulia\n \nusing\n \nOpenDSSDirect\n\n\n\nDSS\n \ncompile\n \nC\n:\n\\\\\nportableapps\n\\\\\nhome\n\\\\\n.\njulia\n\\\\\nv0\n.\n4\n\\\\\nOpenDSSDirect\n\\\\\nexamples\n\\\\\n8500\n-\nNode\n\\\\\nMaster\n.\ndss\n\n\n\nDSS\n \nsolve\n\n\n\nDSS\n \nsummary\n\n\nStatus\n \n=\n \nNOT\n \nSolved\n\n\nSolution\n \nMode\n \n=\n \nSnap\n\n\nNumber\n \n=\n \n100\n\n\nLoad\n \nMult\n \n=\n \n1.000\n\n\nDevices\n \n=\n \n6103\n\n\nBuses\n \n=\n \n4876\n\n\nNodes\n \n=\n \n8541\n\n\nControl\n \nMode\n \n=\nSTATIC\n\n\nTotal\n \nIterations\n \n=\n \n23\n\n\nControl\n \nIterations\n \n=\n \n2\n\n\nMax\n \nSol\n \nIter\n \n=\n \n15\n\n\n \n-\n \nCircuit\n \nSummary\n \n-\n\n\n\nYear\n \n=\n \n0\n\n\nHour\n \n=\n \n0\n\n\nMax\n \npu\n.\n \nvoltage\n \n=\n \n1.0991\n\n\nMin\n \npu\n.\n \nvoltage\n \n=\n \n0.91736\n\n\nTotal\n \nActive\n \nPower\n:\n   \n12.0047\n \nMW\n\n\nTotal\n \nReactive\n \nPower\n:\n \n1.47117\n \nMvar\n\n\nTotal\n \nActive\n \nLosses\n:\n   \n1.21824\n \nMW\n,\n \n(\n10.15\n \n%\n)\n\n\nTotal\n \nReactive\n \nLosses\n:\n \n2.79839\n \nMvar\n\n\nFrequency\n \n=\n \n60\n \nHz\n\n\nMode\n \n=\n \nSnap\n\n\nControl\n \nMode\n \n=\n \nSTATIC\n\n\nLoad\n \nModel\n \n=\n \nPowerFlow\n\n\n\n\n\n\nThe DSS mode also has help. Hit \n?\n at the \nDSS\n prompt, and enter options or commands you want help on. \n\n\nDSS\n \nclear\n\n\n\nDSS\n \nhelp\n?\n \nclear\n\n\nClear\n \nall\n \ncircuits\n \ncurrently\n \nin\n \nmemory\n.\n\n\n\nDSS\n \nhelp\n?\n \nsolve\n\n\nPerform\n \nthe\n \nsolution\n \nof\n \nthe\n \npresent\n \nsolution\n \nmode\n.\n \nYou\n \ncan\n \nset\n \nany\n \noption\n \nthat\n \nyou\n \ncan\n \nset\n \nwith\n \nthe\n \nSet\n \ncommand\n \n(\nsee\n \nSet\n)\n.\n \nThe\n \nSolve\n \ncommand\n \nis\n \nvirtually\n \nsynonymous\n \nwith\n \nthe\n \nSet\n \ncommand\n \nexcept\n \nthat\n \na\n \nsolution\n \nis\n \nperformed\n \nafter\n \nthe\n \noptions\n \nare\n \nprocessed\n.", 
            "title": "DSS mode"
        }, 
        {
            "location": "/dssmode/#dss-repl-mode", 
            "text": "OpenDSSDirect also includes a custom REPL mode for entering OpenDSS commands directly. This is similar to the Help ( ? ) and Shell ( ; ) modes. Use the right square bracket ( ] ) to enter DSS mode. Hit backspace on a blank line to exit. Here is an example:  julia   using   OpenDSSDirect  DSS   compile   C : \\\\ portableapps \\\\ home \\\\ . julia \\\\ v0 . 4 \\\\ OpenDSSDirect \\\\ examples \\\\ 8500 - Node \\\\ Master . dss  DSS   solve  DSS   summary  Status   =   NOT   Solved  Solution   Mode   =   Snap  Number   =   100  Load   Mult   =   1.000  Devices   =   6103  Buses   =   4876  Nodes   =   8541  Control   Mode   = STATIC  Total   Iterations   =   23  Control   Iterations   =   2  Max   Sol   Iter   =   15 \n\n  -   Circuit   Summary   -  Year   =   0  Hour   =   0  Max   pu .   voltage   =   1.0991  Min   pu .   voltage   =   0.91736  Total   Active   Power :     12.0047   MW  Total   Reactive   Power :   1.47117   Mvar  Total   Active   Losses :     1.21824   MW ,   ( 10.15   % )  Total   Reactive   Losses :   2.79839   Mvar  Frequency   =   60   Hz  Mode   =   Snap  Control   Mode   =   STATIC  Load   Model   =   PowerFlow   The DSS mode also has help. Hit  ?  at the  DSS  prompt, and enter options or commands you want help on.   DSS   clear  DSS   help ?   clear  Clear   all   circuits   currently   in   memory .  DSS   help ?   solve  Perform   the   solution   of   the   present   solution   mode .   You   can   set   any   option   that   you   can   set   with   the   Set   command   ( see   Set ) .   The   Solve   command   is   virtually   synonymous   with   the   Set   command   except   that   a   solution   is   performed   after   the   options   are   processed .", 
            "title": "DSS REPL Mode"
        }, 
        {
            "location": "/lowlevel/", 
            "text": "Low-level API (module DSSCore)\n\n\nThe main API is built on the low-level API documented  \nhere\n. The low-level API is implemented in the \nDSSCore\n module. Here is an example using the low-level API:\n\n\nDSSCore\n.\nDSSPut_Command\n(\nclear\n)\n\n\nDSSCore\n.\nDSSPut_Command\n(\ncompile (C:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss)\n)\n\n\nloadnumber\n \n=\n \nDSSCore\n.\nDSSLoads\n(\n0\n,\n \n0\n)\n\n\nwhile\n \nloadnumber\n \n \n0\n\n    \nDSSCore\n.\nDSSLoadsF\n(\n1\n,\n \n50.\n)\n\n    \nDSSCore\n.\nDSSLoadsF\n(\n5\n,\n \n20.\n)\n\n    \nloadnumber\n \n=\n \nDSSCore\n.\nDSSLoads\n(\n1\n,\n \n0\n)\n\n\nend\n\n\nprintln\n(\nDSSCore\n.\nDSSLoads\n(\n4\n,\n \n0\n))\n \n\n\n\n\n\nInteger (I), floating-point (F), string (S), and variant (V) functions are supported. The low-level API functions are not exported. \n\n\nThis low-level API also includes several functions for directly accessing and  controlling an OpenDSS solution. These functions include \n\n\n\n\nAddInAuxCurrents\n\n\nBuildYMatrixD\n\n\nGetPCInjCurr\n\n\nGetSourceInjCurrents\n\n\nSolveSystem\n\n\nSystemYChanged\n\n\nUseAuxCurrents\n\n\nZeroInjCurr\n\n\ngetI\n\n\ngetV\n\n\ngetYsparse\n\n\n\n\n...\n\n\n#\nOpenDSSDirect.DSSCore.getI\n \n \nFunction\n.\n\n\n\n\ngetI()\n \u2013 Return the complex vector of current injections. \n\n\nThe size of the vector is one more than the number of nodes in the system. This is the same current injection array used in OpenDSS internally, so the current injections can be updated for custom solutions. This could be used to implement a custom power control component.\n\n\n#\nOpenDSSDirect.DSSCore.getV\n \n \nFunction\n.\n\n\n\n\ngetV()\n \u2013 Return the complex vector of node voltages. \n\n\nThe size of the vector is one more than the number of nodes in the system. The first element is ground (zero volts). This is the same voltage array used in OpenDSS internally, so the voltages can be updated for custom solutions. \n\n\n#\nOpenDSSDirect.DSSCore.getYsparse\n \n \nFunction\n.\n\n\n\n\ngetYsparse()\n \u2013 Return the system sparse Y matrix.\n\n\n#\nOpenDSSDirect.DSSCore.ZeroInjCurr\n \n \nFunction\n.\n\n\n\n\nZeroInjCurr()\n \u2013 Zero out the current injections vector.\n\n\n#\nOpenDSSDirect.DSSCore.GetSourceInjCurrents\n \n \nFunction\n.\n\n\n\n\nGetSourceInjCurrents()\n \u2013 Update the current injections vector with source injections.\n\n\n#\nOpenDSSDirect.DSSCore.GetPCInjCurr\n \n \nFunction\n.\n\n\n\n\nGetPCInjCurr()\n \u2013 Update the current injections vector with injections from power control elements like loads.\n\n\n#\nOpenDSSDirect.DSSCore.SystemYChanged\n \n \nFunction\n.\n\n\n\n\nSystemYChanged(arg)\n \u2013 Set the status of whether the system Y matrix has changed.\n\n\nSystemYChanged()\n \u2013 Bool indicating whether the system Y matrix has changed.\n\n\n#\nOpenDSSDirect.DSSCore.BuildYMatrixD\n \n \nFunction\n.\n\n\n\n\nBuildYMatrixD(buildops::Integer, doallocate)\n \u2013 Rebuild the system Y matrix. \n\n\n\n\nbuildops::Integer\n indicates the type of build. \n0 == WHOLEMATRIX\n and \n1 == SERIESONLY\n.\n\n\ndoallocate::Bool\n is used to determine whether to allocate the Y matrix.\n\n\n\n\n#\nOpenDSSDirect.DSSCore.UseAuxCurrents\n \n \nFunction\n.\n\n\n\n\nUseAuxCurrents(arg)\n \u2013 Set the status of whether to use auxiliary currents.\n\n\nUseAuxCurrents()\n \u2013 Bool indicating whether to use auxiliary currents.\n\n\n#\nOpenDSSDirect.DSSCore.AddInAuxCurrents\n \n \nFunction\n.\n\n\n\n\nUseAuxCurrents(arg)\n \u2013 ??\n\n\n#\nOpenDSSDirect.DSSCore.SolveSystem\n \n \nFunction\n.\n\n\n\n\nSolveSystem()\n \u2013 Update the system node voltages based on the vector of current injections.\n\n\n\n\nLimitations\n\n\nThe functions with input parameters that are Variants are not implemented. An example is \nDSSCore.SettingsV(5, arg)\n where \narg\n is an Array. These variants are normally array inputs. There are not many of these in the direct API, and most can be handled with the text interface or other functions. Functions that retrieve Variants are supported.", 
            "title": "Low level API"
        }, 
        {
            "location": "/lowlevel/#low-level-api-module-dsscore", 
            "text": "The main API is built on the low-level API documented   here . The low-level API is implemented in the  DSSCore  module. Here is an example using the low-level API:  DSSCore . DSSPut_Command ( clear )  DSSCore . DSSPut_Command ( compile (C:/OpenDSS/electricdss/IEEETestCases/8500-Node/Master.dss) )  loadnumber   =   DSSCore . DSSLoads ( 0 ,   0 )  while   loadnumber     0 \n     DSSCore . DSSLoadsF ( 1 ,   50. ) \n     DSSCore . DSSLoadsF ( 5 ,   20. ) \n     loadnumber   =   DSSCore . DSSLoads ( 1 ,   0 )  end  println ( DSSCore . DSSLoads ( 4 ,   0 ))    Integer (I), floating-point (F), string (S), and variant (V) functions are supported. The low-level API functions are not exported.   This low-level API also includes several functions for directly accessing and  controlling an OpenDSS solution. These functions include    AddInAuxCurrents  BuildYMatrixD  GetPCInjCurr  GetSourceInjCurrents  SolveSystem  SystemYChanged  UseAuxCurrents  ZeroInjCurr  getI  getV  getYsparse   ...  # OpenDSSDirect.DSSCore.getI     Function .   getI()  \u2013 Return the complex vector of current injections.   The size of the vector is one more than the number of nodes in the system. This is the same current injection array used in OpenDSS internally, so the current injections can be updated for custom solutions. This could be used to implement a custom power control component.  # OpenDSSDirect.DSSCore.getV     Function .   getV()  \u2013 Return the complex vector of node voltages.   The size of the vector is one more than the number of nodes in the system. The first element is ground (zero volts). This is the same voltage array used in OpenDSS internally, so the voltages can be updated for custom solutions.   # OpenDSSDirect.DSSCore.getYsparse     Function .   getYsparse()  \u2013 Return the system sparse Y matrix.  # OpenDSSDirect.DSSCore.ZeroInjCurr     Function .   ZeroInjCurr()  \u2013 Zero out the current injections vector.  # OpenDSSDirect.DSSCore.GetSourceInjCurrents     Function .   GetSourceInjCurrents()  \u2013 Update the current injections vector with source injections.  # OpenDSSDirect.DSSCore.GetPCInjCurr     Function .   GetPCInjCurr()  \u2013 Update the current injections vector with injections from power control elements like loads.  # OpenDSSDirect.DSSCore.SystemYChanged     Function .   SystemYChanged(arg)  \u2013 Set the status of whether the system Y matrix has changed.  SystemYChanged()  \u2013 Bool indicating whether the system Y matrix has changed.  # OpenDSSDirect.DSSCore.BuildYMatrixD     Function .   BuildYMatrixD(buildops::Integer, doallocate)  \u2013 Rebuild the system Y matrix.    buildops::Integer  indicates the type of build.  0 == WHOLEMATRIX  and  1 == SERIESONLY .  doallocate::Bool  is used to determine whether to allocate the Y matrix.   # OpenDSSDirect.DSSCore.UseAuxCurrents     Function .   UseAuxCurrents(arg)  \u2013 Set the status of whether to use auxiliary currents.  UseAuxCurrents()  \u2013 Bool indicating whether to use auxiliary currents.  # OpenDSSDirect.DSSCore.AddInAuxCurrents     Function .   UseAuxCurrents(arg)  \u2013 ??  # OpenDSSDirect.DSSCore.SolveSystem     Function .   SolveSystem()  \u2013 Update the system node voltages based on the vector of current injections.", 
            "title": "Low-level API (module DSSCore)"
        }, 
        {
            "location": "/lowlevel/#limitations", 
            "text": "The functions with input parameters that are Variants are not implemented. An example is  DSSCore.SettingsV(5, arg)  where  arg  is an Array. These variants are normally array inputs. There are not many of these in the direct API, and most can be handled with the text interface or other functions. Functions that retrieve Variants are supported.", 
            "title": "Limitations"
        }, 
        {
            "location": "/docindex/", 
            "text": "Documentation Index\n\n\n\n\nActiveClass\n\n\nBasic\n\n\nBus\n\n\nCapControls\n\n\nCapacitors\n\n\nCircuit\n\n\nCktElement\n\n\nCtrlQueue\n\n\nElement\n\n\nExecutive\n\n\nFuses\n\n\nGenerators\n\n\nIsource\n\n\nLines\n\n\nLoadShape\n\n\nLoads\n\n\nMeters\n\n\nMonitors\n\n\nPDElements\n\n\nPVsystems\n\n\nParser\n\n\nProgress\n\n\nProperties\n\n\nReclosers\n\n\nRegControls\n\n\nRelays\n\n\nSensors\n\n\nSettings\n\n\nSolution\n\n\nSwtControls\n\n\nTopology\n\n\nTransformers\n\n\nVsources\n\n\nXYCurves\n\n\ndss\n\n\nActionCodes\n\n\nCapControlModes\n\n\nLineUnits\n\n\nLoadModels\n\n\nLoadStatus\n\n\nMonitorModes\n\n\nOptions\n\n\nSolveModes\n\n\nAddInAuxCurrents\n\n\nBuildYMatrixD\n\n\nGetPCInjCurr\n\n\nGetSourceInjCurrents\n\n\nSolveSystem\n\n\nSystemYChanged\n\n\nUseAuxCurrents\n\n\nZeroInjCurr\n\n\ngetI\n\n\ngetV\n\n\ngetYsparse", 
            "title": "Index"
        }, 
        {
            "location": "/docindex/#documentation-index", 
            "text": "ActiveClass  Basic  Bus  CapControls  Capacitors  Circuit  CktElement  CtrlQueue  Element  Executive  Fuses  Generators  Isource  Lines  LoadShape  Loads  Meters  Monitors  PDElements  PVsystems  Parser  Progress  Properties  Reclosers  RegControls  Relays  Sensors  Settings  Solution  SwtControls  Topology  Transformers  Vsources  XYCurves  dss  ActionCodes  CapControlModes  LineUnits  LoadModels  LoadStatus  MonitorModes  Options  SolveModes  AddInAuxCurrents  BuildYMatrixD  GetPCInjCurr  GetSourceInjCurrents  SolveSystem  SystemYChanged  UseAuxCurrents  ZeroInjCurr  getI  getV  getYsparse", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/NEWS/", 
            "text": "OpenDSSDirect v0.1.1 Release Notes\n\n\n\n\nInitial release", 
            "title": "Release notes"
        }, 
        {
            "location": "/NEWS/#opendssdirect-v011-release-notes", 
            "text": "Initial release", 
            "title": "OpenDSSDirect v0.1.1 Release Notes"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The OpenDSSDirect.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2015: Electric Power Research Institute.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nThis package also includes dynamic libraries for OpenDSS. OpenDSS is Copyright (c) 2008-2015, Electric Power Research Institute, Inc. It is published under a three-clause BSD license. See here:\n\n\n\n\nhttp://sourceforge.net/p/electricdss/code/HEAD/tree/trunk/License.txt\n\n\nhttp://sourceforge.net/p/electricdss/code/HEAD/tree/trunk/\n\n\n\n\nThis package also includes dynamic libraries for KLUSolve.   KLUSolve 1.0 is Copyright (c) 2008, EnerNex Corporation.  It is published under the LGPL, version 2.1 or later. For  code and license information, see the following:\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/License.txt\n\n\n\n\nKLUSolve contains open-source copyrighted code as follows. These are also released under the LGPL, version 2.1 or later.\n\n\nKLU Version 1.0, May 31, 2007, by Timothy A. Davis and Ekanathan Palamadai. Copyright (C) 2004-2007, University of Florida.\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/KLU/\n\n\n\n\nCSparse: a Concise Sparse Matrix package. Version 2.2.0, Copyright (c) 2006-2007, Timothy A. Davis, Mar 31, 2007.\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/CSparse/\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/CSparse/Doc/License.txt\n\n\n\n\nAMD Version 2.2, Copyright (c) 2007 by Timothy A. Davis, Patrick R. Amestoy, and Iain S. Duff.\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/AMD/\n\n\n\n\nBTF Version 1.0, May 31, 2007, by Timothy A. Davis Copyright (C) 2004-2007, University of Florida\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/BTF/\n\n\n\n\nCZSparse, Copyright (c) 2008, EnerNex Corporation.\n\n\n\n\nhttp://sourceforge.net/p/klusolve/code/HEAD/tree/CZSparse/", 
            "title": "License"
        }
    ]
}